<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>.eunit/mysql_connection.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /Users/viktor/data/mysql-otp/.eunit/mysql_connection.erl by COVER 2014-12-04 at 00:38:54

****************************************************************************

        |  %% MySQL/OTP – MySQL client library for Erlang/OTP
        |  %% Copyright (C) 2014 Viktor Söderqvist
        |  %%
        |  %% This file is part of MySQL/OTP.
        |  %%
        |  %% MySQL/OTP is free software: you can redistribute it and/or modify it under
        |  %% the terms of the GNU Lesser General Public License as published by the Free
        |  %% Software Foundation, either version 3 of the License, or (at your option)
        |  %% any later version.
        |  %%
        |  %% This program is distributed in the hope that it will be useful, but WITHOUT
        |  %% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
        |  %% FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
        |  %% more details.
        |  %%
        |  %% You should have received a copy of the GNU Lesser General Public License
        |  %% along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
        |  
        |  %% A mysql connection implemented as a gen_server. This is a gen_server callback
        |  %% module only. The API functions are located in the mysql module.
        |  -module(mysql_connection).
        |  -behaviour(gen_server).
        |  
        |  %% API functions
        |  -export([start_link/1]).
        |  
        |  %% Gen_server callbacks
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,
        |           code_change/3]).
        |  
        |  -define(default_host, "localhost").
        |  -define(default_port, 3306).
        |  -define(default_user, &lt;&lt;&gt;&gt;).
        |  -define(default_password, &lt;&lt;&gt;&gt;).
        |  -define(default_timeout, infinity).
        |  
        |  -include("records.hrl").
        |  -include("server_status.hrl").
        |  
        |  %% Gen_server state
        |  -record(state, {socket, timeout = infinity, affected_rows = 0, status = 0,
        |                  warning_count = 0, insert_id = 0, stmts = dict:new()}).
        |  
        |  %% A tuple representing a MySQL server error, typically returned in the form
        |  %% {error, reason()}.
        |  -type reason() :: {Code :: integer(), SQLState :: binary(), Msg :: binary()}.
        |  
        |  %% @doc Starts a connection gen_server and links to it. The options are
        |  %% described in mysql:start_link/1.
        |  %% @see mysql:start_link/1.
        |  start_link(Options) -&gt;
     3..|      case proplists:get_value(name, Options) of
        |          undefined -&gt;
     2..|              gen_server:start_link(mysql_connection, Options, []);
        |          ServerName -&gt;
     1..|              gen_server:start_link(ServerName, mysql_connection, Options, [])
        |      end.
        |  
        |  %% --- Gen_server callbacks ---
        |  
        |  init(Opts) -&gt;
        |      %% Connect
     3..|      Host     = proplists:get_value(host,     Opts, ?default_host),
     3..|      Port     = proplists:get_value(port,     Opts, ?default_port),
     3..|      User     = proplists:get_value(user,     Opts, ?default_user),
     3..|      Password = proplists:get_value(password, Opts, ?default_password),
     3..|      Database = proplists:get_value(database, Opts, undefined),
     3..|      Timeout  = proplists:get_value(timeout,  Opts, ?default_timeout),
        |  
        |      %% Connect socket
     3..|      SockOpts = [{active, false}, binary, {packet, raw}],
     3..|      {ok, Socket} = gen_tcp:connect(Host, Port, SockOpts),
        |  
        |      %% Exchange handshake communication.
     3..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
     3..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
     3..|      Result = mysql_protocol:handshake(User, Password, Database, SendFun,
        |                                        RecvFun),
     3..|      case Result of
        |          #ok{} = OK -&gt;
     3..|              State = #state{socket = Socket, timeout = Timeout},
     3..|              State1 = update_state(State, OK),
        |              %% Trap exit so that we can properly disconnect when we die.
     3..|              process_flag(trap_exit, true),
     3..|              {ok, State1};
        |          #error{} = E -&gt;
<font color=red>     0..|              {stop, error_to_reason(E)}</font>
        |      end.
        |  
        |  handle_call({query, Query}, _From, State) when is_binary(Query);
        |                                                 is_list(Query) -&gt;
   131..|      #state{socket = Socket, timeout = Timeout} = State,
   131..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
   131..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
   131..|      Rec = mysql_protocol:query(Query, SendFun, RecvFun),
   131..|      State1 = update_state(State, Rec),
   131..|      case Rec of
        |          #ok{} -&gt;
    84..|              {reply, ok, State1};
        |          #error{} = E -&gt;
     1..|              {reply, {error, error_to_reason(E)}, State1};
        |          #resultset{column_definitions = ColDefs, rows = Rows} -&gt;
    46..|              Names = [Def#column_definition.name || Def &lt;- ColDefs],
    46..|              {reply, {ok, Names, Rows}, State1}
        |      end;
        |  handle_call({execute, Stmt, Args}, _From, State) -&gt;
    73..|      case dict:find(Stmt, State#state.stmts) of
        |          {ok, StmtRec} -&gt;
    72..|              #state{socket = Socket, timeout = Timeout} = State,
    72..|              SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
    72..|              RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
    72..|              Rec = mysql_protocol:execute(StmtRec, Args, SendFun, RecvFun),
    72..|              State1 = update_state(State, Rec),
    72..|              case Rec of
        |                  #ok{} -&gt;
    31..|                      {reply, ok, State1};
        |                  #error{} = E -&gt;
<font color=red>     0..|                      {reply, {error, error_to_reason(E)}, State1};</font>
        |                  #resultset{column_definitions = ColDefs, rows = Rows} -&gt;
    41..|                      Names = [Def#column_definition.name || Def &lt;- ColDefs],
    41..|                      {reply, {ok, Names, Rows}, State1}
        |              end;
        |          error -&gt;
     1..|              {reply, {error, not_prepared}, State}
        |      end;
        |  handle_call({prepare, Query}, _From, State) -&gt;
    11..|      #state{socket = Socket, timeout = Timeout} = State,
    11..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
    11..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
    11..|      Rec = mysql_protocol:prepare(Query, SendFun, RecvFun),
    11..|      State1 = update_state(State, Rec),
    11..|      case Rec of
        |          #error{} = E -&gt;
     1..|              {reply, {error, error_to_reason(E)}, State1};
        |          #prepared{statement_id = Id} = Stmt -&gt;
    10..|              Stmts1 = dict:store(Id, Stmt, State1#state.stmts),
    10..|              State2 = State#state{stmts = Stmts1},
    10..|              {reply, {ok, Id}, State2}
        |      end;
        |  handle_call({prepare, Name, Query}, _From, State) when is_atom(Name) -&gt;
     3..|      #state{socket = Socket, timeout = Timeout} = State,
     3..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
     3..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
        |      %% First unprepare if there is an old statement with this name.
     3..|      State1 = case dict:find(Name, State#state.stmts) of
        |          {ok, OldStmt} -&gt;
     1..|              mysql_protocol:unprepare(OldStmt, SendFun, RecvFun),
     1..|              State#state{stmts = dict:erase(Name, State#state.stmts)};
        |          error -&gt;
     2..|              State
        |      end,
     3..|      Rec = mysql_protocol:prepare(Query, SendFun, RecvFun),
     3..|      State2 = update_state(State1, Rec),
     3..|      case Rec of
        |          #error{} = E -&gt;
     1..|              {reply, {error, error_to_reason(E)}, State2};
        |          #prepared{} = Stmt -&gt;
     2..|              Stmts1 = dict:store(Name, Stmt, State2#state.stmts),
     2..|              State3 = State2#state{stmts = Stmts1},
     2..|              {reply, {ok, Name}, State3}
        |      end;
        |  handle_call({unprepare, Name}, _From, State) -&gt;
     4..|      case dict:find(Name, State#state.stmts) of
        |          {ok, StmtRec} -&gt;
     2..|              #state{socket = Socket, timeout = Timeout} = State,
     2..|              SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
     2..|              RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
     2..|              mysql_protocol:unprepare(StmtRec, SendFun, RecvFun),
     2..|              Stmts1 = dict:erase(Name, State#state.stmts),
     2..|              {reply, ok, State#state{stmts = Stmts1}};
        |          error -&gt;
     2..|              {reply, {error, not_prepared}, State}
        |      end;
        |  handle_call(warning_count, _From, State) -&gt;
     2..|      {reply, State#state.warning_count, State};
        |  handle_call(insert_id, _From, State) -&gt;
     1..|      {reply, State#state.insert_id, State};
        |  handle_call(affected_rows, _From, State) -&gt;
     1..|      {reply, State#state.affected_rows, State};
        |  handle_call(autocommit, _From, State) -&gt;
     3..|      {reply, State#state.status band ?SERVER_STATUS_AUTOCOMMIT /= 0, State};
        |  handle_call(in_transaction, _From, State) -&gt;
     3..|      {reply, State#state.status band ?SERVER_STATUS_IN_TRANS /= 0, State};
        |  %handle_call(get_state, _From, State) -&gt;
        |  %    %% *** FOR DEBUGGING ***
        |  %    {reply, State, State}.
        |  handle_call(_Msg, _From, State) -&gt;
<font color=red>     0..|      {reply, {error, invalid_message}, State}.</font>
        |  
        |  handle_cast(_Msg, State) -&gt;
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  handle_info(_Info, State) -&gt;
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  terminate(_Reason, State) -&gt;
        |      %% Send the goodbye message for politeness.
     3..|      #state{socket = Socket, timeout = Timeout} = State,
     3..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
     3..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
     3..|      mysql_protocol:quit(SendFun, RecvFun).
        |  
        |  code_change(_OldVsn, State, _Extra) -&gt;
<font color=red>     0..|      {ok, State}.</font>
        |  
        |  %% --- Helpers ---
        |  
        |  %% @doc Produces a tuple to return when an error needs to be returned to in the
        |  %% public API.
        |  -spec error_to_reason(#error{}) -&gt; reason().
        |  error_to_reason(#error{code = Code, state = State, msg = Msg}) -&gt;
     3..|      {Code, State, Msg}.
        |  
        |  %% @doc Updates a state with information from a response.
        |  -spec update_state(#state{}, #ok{} | #eof{} | any()) -&gt; #state{}.
        |  update_state(State, #ok{status = S, affected_rows = R,
        |                          insert_id = Id, warning_count = W}) -&gt;
   118..|      State#state{status = S, affected_rows = R, insert_id = Id,
        |                  warning_count = W};
        |  update_state(State, #eof{status = S, warning_count = W}) -&gt;
<font color=red>     0..|      State#state{status = S, warning_count = W, affected_rows = 0};</font>
        |  update_state(State, _Other) -&gt;
        |      %% This includes errors, resultsets, etc.
        |      %% Reset warnings, etc. (Note: We don't reset status and insert_id.)
   102..|      State#state{warning_count = 0, affected_rows = 0}.
</pre>
</body>
</html>
