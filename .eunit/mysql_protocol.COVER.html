<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>.eunit/mysql_protocol.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /Users/viktor/data/mysql-otp/.eunit/mysql_protocol.erl by COVER 2014-11-30 at 22:39:37

****************************************************************************

        |  %% MySQL/OTP – MySQL client library for Erlang/OTP
        |  %% Copyright (C) 2014 Viktor Söderqvist
        |  %%
        |  %% This file is part of MySQL/OTP.
        |  %%
        |  %% MySQL/OTP is free software: you can redistribute it and/or modify it under
        |  %% the terms of the GNU Lesser General Public License as published by the Free
        |  %% Software Foundation, either version 3 of the License, or (at your option)
        |  %% any later version.
        |  %%
        |  %% This program is distributed in the hope that it will be useful, but WITHOUT
        |  %% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
        |  %% FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
        |  %% more details.
        |  %%
        |  %% You should have received a copy of the GNU Lesser General Public License
        |  %% along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
        |  
        |  %% @doc This module implements parts of the MySQL client/server protocol.
        |  %%
        |  %% The protocol is described in the document "MySQL Internals" which can be
        |  %% found under "MySQL Documentation: Expert Guides" on http://dev.mysql.com/.
        |  %%
        |  %% TCP communication is not handled in this module. Most of the public functions
        |  %% take funs for data communitaction as parameters.
        |  -module(mysql_protocol).
        |  
        |  -export([handshake/5,
        |           query/3,
        |           prepare/3, execute/4]).
        |  
        |  -export_type([sendfun/0, recvfun/0]).
        |  
        |  -type sendfun() :: fun((binary()) -&gt; ok).
        |  -type recvfun() :: fun((integer()) -&gt; {ok, binary()}).
        |  
        |  %% How much data do we want to send at most?
        |  -define(MAX_BYTES_PER_PACKET, 50000000).
        |  
        |  -include("records.hrl").
        |  -include("protocol.hrl").
        |  
        |  %% Macros for pattern matching on packets.
        |  -define(ok_pattern, &lt;&lt;?OK, _/binary&gt;&gt;).
        |  -define(error_pattern, &lt;&lt;?ERROR, _/binary&gt;&gt;).
        |  -define(eof_pattern, &lt;&lt;?EOF, _:4/binary&gt;&gt;).
        |  
        |  %% @doc Performs a handshake using the supplied functions for communication.
        |  %% Returns an ok or an error record. Raises errors when various unimplemented
        |  %% features are requested.
        |  %%
        |  %% TODO: Implement setting the database in the handshake. Currently an error
        |  %% occurs if Database is anything other than undefined.
        |  -spec handshake(iodata(), iodata(), iodata() | undefined, sendfun(),
        |                  recvfun()) -&gt; #ok{} | #error{}.
        |  handshake(Username, Password, Database, SendFun, RecvFun) -&gt;
     3..|      SeqNum0 = 0,
     3..|      Database == undefined orelse error(database_in_handshake),
     3..|      {ok, HandshakePacket, SeqNum1} = recv_packet(RecvFun, SeqNum0),
     3..|      Handshake = parse_handshake(HandshakePacket),
     3..|      Response = build_handshake_response(Handshake, Username, Password),
     3..|      {ok, SeqNum2} = send_packet(SendFun, Response, SeqNum1),
     3..|      {ok, ConfirmPacket, _SeqNum3} = recv_packet(RecvFun, SeqNum2),
     3..|      parse_handshake_confirm(ConfirmPacket).
        |  
        |  -spec query(Query :: iodata(), sendfun(), recvfun()) -&gt;
        |      #ok{} | #error{} | #resultset{}.
        |  query(Query, SendFun, RecvFun) -&gt;
   133..|      Req = &lt;&lt;?COM_QUERY, (iolist_to_binary(Query))/binary&gt;&gt;,
   133..|      SeqNum0 = 0,
   133..|      {ok, SeqNum1} = send_packet(SendFun, Req, SeqNum0),
   133..|      {ok, Resp, SeqNum2} = recv_packet(RecvFun, SeqNum1),
   133..|      case Resp of
        |          ?ok_pattern -&gt;
    84..|              parse_ok_packet(Resp);
        |          ?error_pattern -&gt;
     1..|              parse_error_packet(Resp);
        |          _ResultSet -&gt;
        |              %% The first packet in a resultset is only the column count.
    48..|              {ColumnCount, &lt;&lt;&gt;&gt;} = lenenc_int(Resp),
    48..|              case fetch_resultset(RecvFun, ColumnCount, SeqNum2) of
        |                  #error{} = E -&gt;
     1..|                      E;
        |                  #resultset{column_definitions = ColDefs, rows = Rows} = R -&gt;
        |                      %% Parse the rows according to the 'text protocol'
        |                      %% representation.
    47..|                      ColumnTypes = [ColDef#column_definition.type
    47..|                                     || ColDef &lt;- ColDefs],
    47..|                      Rows1 = [decode_text_row(ColumnCount, ColumnTypes, Row)
    47..|                               || Row &lt;- Rows],
    47..|                      R#resultset{rows = Rows1}
        |              end
        |      end.
        |  
        |  %% @doc Prepares a statement.
        |  -spec prepare(iodata(), sendfun(), recvfun()) -&gt; #error{} | #prepared{}.
        |  prepare(Query, SendFun, RecvFun) -&gt;
    10..|      Req = &lt;&lt;?COM_STMT_PREPARE, (iolist_to_binary(Query))/binary&gt;&gt;,
    10..|      {ok, SeqNum1} = send_packet(SendFun, Req, 0),
    10..|      {ok, Resp, SeqNum2} = recv_packet(RecvFun, SeqNum1),
    10..|      case Resp of
        |          ?error_pattern -&gt;
<font color=red>     0..|              parse_error_packet(Resp);</font>
        |          &lt;&lt;?OK,
        |            StmtId:32/little,
        |            NumColumns:16/little,
        |            NumParams:16/little,
        |            0, %% reserved_1 -- [00] filler
        |            WarningCount:16/little&gt;&gt; -&gt;
        |              %% This was the first packet.
        |              %% Now: Parameter Definition Block. The parameter definitions don't
        |              %% contain any useful data at all. They are always TYPE_VAR_STRING
        |              %% with charset 'binary' so we have to select a type ourselves for
        |              %% the parameters we have in execute/4.
    10..|              {_ParamDefs, SeqNum3} =
        |                  fetch_column_definitions_if_any(NumParams, RecvFun, SeqNum2),
        |              %% Column Definition Block. We get column definitions in execute
        |              %% too, so we don't need them here. We *could* store them to be able
        |              %% to provide the user with some info about a prepared statement.
    10..|              {_ColDefs, _SeqNum4} =
        |                  fetch_column_definitions_if_any(NumColumns, RecvFun, SeqNum3),
    10..|              #prepared{statement_id = StmtId,
        |                        param_count = NumParams,
        |                        warning_count = WarningCount}
        |      end.
        |  
        |  %% @doc Executes a prepared statement.
        |  -spec execute(#prepared{}, [term()], sendfun(), recvfun()) -&gt; #resultset{}.
        |  execute(#prepared{statement_id = Id, param_count = ParamCount}, ParamValues,
        |          SendFun, RecvFun) when ParamCount == length(ParamValues) -&gt;
        |      %% Flags Constant Name
        |      %% 0x00 CURSOR_TYPE_NO_CURSOR
        |      %% 0x01 CURSOR_TYPE_READ_ONLY
        |      %% 0x02 CURSOR_TYPE_FOR_UPDATE
        |      %% 0x04 CURSOR_TYPE_SCROLLABLE
    72..|      Flags = 0,
    72..|      Req0 = &lt;&lt;?COM_STMT_EXECUTE, Id:32/little, Flags, 1:32/little&gt;&gt;,
    72..|      Req = case ParamCount of
        |          0 -&gt;
    40..|              Req0;
        |          _ -&gt;
        |              %% We can't use the parameter types returned by the prepare call.
        |              %% They are all reported as ?TYPE_VAR_STRING with character
        |              %% set 'binary'.
    32..|              NullBitMap = build_null_bitmap(ParamValues),
        |              %% What does it mean to *not* bind new params? To use the same
        |              %% params as last time? Right now we always bind params each time.
    32..|              NewParamsBoundFlag = 1,
    32..|              Req1 = &lt;&lt;Req0/binary, NullBitMap/binary, NewParamsBoundFlag&gt;&gt;,
        |              %% For each value, first append type and signedness (16#80 signed or
        |              %% 00 unsigned) for all values and then the binary encoded values.
    32..|              EncodedParams = lists:map(fun encode_param/1, ParamValues),
    32..|              {TypesAndSigns, EncValues} = lists:unzip(EncodedParams),
    32..|              iolist_to_binary([Req1, TypesAndSigns, EncValues])
        |      end,
    72..|      {ok, SeqNum1} = send_packet(SendFun, Req, 0),
    72..|      {ok, Resp, SeqNum2} = recv_packet(RecvFun, SeqNum1),
    72..|      case Resp of
        |          ?ok_pattern -&gt;
    31..|              parse_ok_packet(Resp);
        |          ?error_pattern -&gt;
<font color=red>     0..|              parse_error_packet(Resp);</font>
        |          _ResultPacket -&gt;
        |              %% The first packet in a resultset is only the column count.
    41..|              {ColumnCount, &lt;&lt;&gt;&gt;} = lenenc_int(Resp),
    41..|              case fetch_resultset(RecvFun, ColumnCount, SeqNum2) of
        |                  #error{} = E -&gt;
        |                      %% TODO: Find a way to get here and write a testcase.
        |                      %% This can happen for the text protocol but maybe not for
        |                      %% the binary protocol.
<font color=red>     0..|                      E;</font>
        |                  #resultset{column_definitions = ColDefs, rows = Rows} = R -&gt;
        |                      %% Parse the rows according to the 'binary protocol'
        |                      %% representation.
    41..|                      ColumnTypes = [ColDef#column_definition.type
    41..|                                     || ColDef &lt;- ColDefs],
    41..|                      Rows1 = [decode_binary_row(ColumnCount, ColumnTypes, Row)
    41..|                               || Row &lt;- Rows],
    41..|                      R#resultset{rows = Rows1}
        |              end
        |      end.
        |  
        |  %% --- internal ---
        |  
        |  %% @doc Parses a handshake. This is the first thing that comes from the server
        |  %% when connecting. If an unsupported version or variant of the protocol is used
        |  %% an error is raised.
        |  -spec parse_handshake(binary()) -&gt; #handshake{}.
        |  parse_handshake(&lt;&lt;10, Rest/binary&gt;&gt;) -&gt;
        |      %% Protocol version 10.
     3..|      {ServerVersion, Rest1} = nulterm_str(Rest),
        |      &lt;&lt;ConnectionId:32/little,
        |        AuthPluginDataPart1:8/binary-unit:8,
        |        0, %% "filler" -- everything below is optional
        |        CapabilitiesLower:16/little,
        |        CharacterSet:8,
        |        StatusFlags:16/little,
        |        CapabilitiesUpper:16/little,
        |        AuthPluginDataLength:8,     %% if cabab &amp; CLIENT_PLUGIN_AUTH, otherwise 0
        |        _Reserved:10/binary-unit:8, %% 10 unused (reserved) bytes
     3..|        Rest3/binary&gt;&gt; = Rest1,
     3..|      Capabilities = CapabilitiesLower + 16#10000 * CapabilitiesUpper,
     3..|      Len = case AuthPluginDataLength of
<font color=red>     0..|          0 -&gt; 13;   %% Server has not CLIENT_PLUGIN_AUTH</font>
     3..|          K -&gt; K - 8 %% Part 2 length = Total length minus the 8 bytes in part 1.
        |      end,
     3..|      &lt;&lt;AuthPluginDataPart2:Len/binary-unit:8, AuthPluginName/binary&gt;&gt; = Rest3,
     3..|      AuthPluginData = &lt;&lt;AuthPluginDataPart1/binary, AuthPluginDataPart2/binary&gt;&gt;,
        |      %% "Due to Bug#59453 the auth-plugin-name is missing the terminating
        |      %% NUL-char in versions prior to 5.5.10 and 5.6.2."
        |      %% Strip the final NUL byte if any.
     3..|      NameLen = size(AuthPluginName) - 1,
     3..|      AuthPluginName1 = case AuthPluginName of
     3..|          &lt;&lt;NameNoNul:NameLen/binary-unit:8, 0&gt;&gt; -&gt; NameNoNul;
<font color=red>     0..|          _ -&gt; AuthPluginName</font>
        |      end,
     3..|      #handshake{server_version = ServerVersion,
        |                connection_id = ConnectionId,
        |                capabilities = Capabilities,
        |                character_set = CharacterSet,
        |                status = StatusFlags,
        |                auth_plugin_data = AuthPluginData,
        |                auth_plugin_name = AuthPluginName1};
        |  parse_handshake(&lt;&lt;Protocol:8, _/binary&gt;&gt;) when Protocol /= 10 -&gt;
<font color=red>     0..|      error(unknown_protocol).</font>
        |  
        |  %% @doc The response sent by the client to the server after receiving the
        |  %% initial handshake from the server
        |  -spec build_handshake_response(#handshake{}, iodata(), iodata()) -&gt; binary().
        |  build_handshake_response(Handshake, Username, Password) -&gt;
        |      %% We require these capabilities. Make sure the server handles them.
     3..|      CapabilityFlags = ?CLIENT_PROTOCOL_41 bor
        |                        ?CLIENT_TRANSACTIONS bor
        |                        ?CLIENT_SECURE_CONNECTION,
     3..|      Handshake#handshake.capabilities band CapabilityFlags == CapabilityFlags
<font color=red>     0..|          orelse error(old_server_version),</font>
     3..|      Hash = case Handshake#handshake.auth_plugin_name of
        |          &lt;&lt;&gt;&gt; -&gt;
        |              %% Server doesn't know auth plugins
<font color=red>     0..|              hash_password(Password, Handshake#handshake.auth_plugin_data);</font>
        |          &lt;&lt;"mysql_native_password"&gt;&gt; -&gt;
     3..|              hash_password(Password, Handshake#handshake.auth_plugin_data);
        |          UnknownAuthMethod -&gt;
<font color=red>     0..|              error({auth_method, UnknownAuthMethod})</font>
        |      end,
     3..|      HashLength = size(Hash),
     3..|      CharacterSet = ?UTF8,
     3..|      UsernameUtf8 = unicode:characters_to_binary(Username),
     3..|      &lt;&lt;CapabilityFlags:32/little,
        |        ?MAX_BYTES_PER_PACKET:32/little,
        |        CharacterSet:8,
        |        0:23/unit:8, %% reserverd
        |        UsernameUtf8/binary,
        |        0, %% NUL-terminator for the username
        |        HashLength,
        |        Hash/binary&gt;&gt;.
        |  
        |  %% @doc Handles the second packet from the server, when we have replied to the
        |  %% initial handshake. Returns an error if the server returns an error. Raises
        |  %% an error if unimplemented features are required.
        |  -spec parse_handshake_confirm(binary()) -&gt; #ok{} | #error{}.
        |  parse_handshake_confirm(Packet) -&gt;
     3..|      case Packet of
        |          ?ok_pattern -&gt;
        |              %% Connection complete.
     3..|              parse_ok_packet(Packet);
        |          ?error_pattern -&gt;
        |              %% "Insufficient Client Capabilities"
<font color=red>     0..|              parse_error_packet(Packet);</font>
        |          &lt;&lt;?EOF&gt;&gt; -&gt;
        |              %% "Old Authentication Method Switch Request Packet consisting of a
        |              %% single 0xfe byte. It is sent by server to request client to
        |              %% switch to Old Password Authentication if CLIENT_PLUGIN_AUTH
        |              %% capability is not supported (by either the client or the server)"
<font color=red>     0..|              error(old_auth);</font>
        |          &lt;&lt;?EOF, _/binary&gt;&gt; -&gt;
        |              %% "Authentication Method Switch Request Packet. If both server and
        |              %% client support CLIENT_PLUGIN_AUTH capability, server can send
        |              %% this packet to ask client to use another authentication method."
<font color=red>     0..|              error(auth_method_switch)</font>
        |      end.
        |  
        |  %% Fetches packets until a
        |  -spec fetch_resultset(recvfun(), integer(), integer()) -&gt;
        |      #resultset{} | #error{}.
        |  fetch_resultset(RecvFun, FieldCount, SeqNum) -&gt;
    89..|      {ok, ColDefs, SeqNum1} = fetch_column_definitions(RecvFun, SeqNum,
        |                                                        FieldCount, []),
    89..|      {ok, DelimiterPacket, SeqNum2} = recv_packet(RecvFun, SeqNum1),
    89..|      #eof{} = parse_eof_packet(DelimiterPacket),
    89..|      case fetch_resultset_rows(RecvFun, SeqNum2, []) of
        |          {ok, Rows, _SeqNum3} -&gt;
    88..|              #resultset{column_definitions = ColDefs, rows = Rows};
        |          #error{} = E -&gt;
     1..|              E
        |      end.
        |  
        |  %% @doc Receives NumLeft packets and parses them as column definitions.
        |  %% TODO: Don't parse them here. That's a sepatate thing we not always need to
        |  %% do.
        |  -spec fetch_column_definitions(recvfun(), SeqNum :: integer(),
        |                                 NumLeft :: integer(), Acc :: [tuple()]) -&gt;
        |      {ok, [tuple()], NextSeqNum :: integer()}.
        |  fetch_column_definitions(RecvFun, SeqNum, NumLeft, Acc) when NumLeft &gt; 0 -&gt;
   142..|      {ok, Packet, SeqNum1} = recv_packet(RecvFun, SeqNum),
   142..|      ColDef = parse_column_definition(Packet),
   142..|      fetch_column_definitions(RecvFun, SeqNum1, NumLeft - 1, [ColDef | Acc]);
        |  fetch_column_definitions(_RecvFun, SeqNum, 0, Acc) -&gt;
   101..|      {ok, lists:reverse(Acc), SeqNum}.
        |  
        |  %% @doc Fetches rows in a result set. There is a packet per row. The row packets
        |  %% are not decoded. This function can be used for both the binary and the text
        |  %% protocol result sets.
        |  -spec fetch_resultset_rows(recvfun(), SeqNum :: integer(), Acc) -&gt;
        |      {ok, Rows, integer()} | #error{}
        |      when Acc :: [binary()],
        |           Rows :: [binary()].
        |  fetch_resultset_rows(RecvFun, SeqNum, Acc) -&gt;
   177..|      {ok, Packet, SeqNum1} = recv_packet(RecvFun, SeqNum),
   177..|      case Packet of
        |          ?error_pattern -&gt;
     1..|              parse_error_packet(Packet);
        |          ?eof_pattern -&gt;
    88..|              {ok, lists:reverse(Acc), SeqNum1};
        |          Row -&gt;
    88..|              fetch_resultset_rows(RecvFun, SeqNum1, [Row | Acc])
        |      end.
        |  
        |  %% -- both text and binary protocol --
        |  
        |  %% Parses a packet containing a column definition (part of a result set)
        |  parse_column_definition(Data) -&gt;
   142..|      {&lt;&lt;"def"&gt;&gt;, Rest1} = lenenc_str(Data),   %% catalog (always "def")
   142..|      {_Schema, Rest2} = lenenc_str(Rest1),    %% schema-name 
   142..|      {_Table, Rest3} = lenenc_str(Rest2),     %% virtual table-name 
   142..|      {_OrgTable, Rest4} = lenenc_str(Rest3),  %% physical table-name 
   142..|      {Name, Rest5} = lenenc_str(Rest4),       %% virtual column name
   142..|      {_OrgName, Rest6} = lenenc_str(Rest5),   %% physical column name
   142..|      {16#0c, Rest7} = lenenc_int(Rest6),      %% length of the following fields
        |                                               %% (always 0x0c)
        |      &lt;&lt;Charset:16/little,        %% column character set
        |        _ColumnLength:32/little,  %% maximum length of the field
        |        ColumnType:8,             %% type of the column as defined in Column Type
        |        _Flags:16/little,         %% flags
        |        _Decimals:8,              %% max shown decimal digits:
        |        0,  %% "filler"           %%   - 0x00 for integers and static strings
        |        0,                        %%   - 0x1f for dynamic strings, double, float
   142..|        Rest8/binary&gt;&gt; = Rest7,   %%   - 0x00 to 0x51 for decimals
        |      %% Here, if command was COM_FIELD_LIST {
        |      %%   default values: lenenc_str
        |      %% }
   142..|      &lt;&lt;&gt;&gt; = Rest8,
   142..|      #column_definition{name = Name, type = ColumnType, charset = Charset}.
        |  
        |  %% -- text protocol --
        |  
        |  -spec decode_text_row(NumColumns :: integer(), ColumnTypes :: integer(),
        |                        Data :: binary()) -&gt; [term()].
        |  decode_text_row(_NumColumns, ColumnTypes, Data) -&gt;
    47..|      decode_text_row_acc(ColumnTypes, Data, []).
        |  
        |  %% parses Data using ColDefs and builds the values Acc.
        |  decode_text_row_acc([Type | Types], Data, Acc) -&gt;
    56..|      case Data of
        |          &lt;&lt;16#fb, Rest/binary&gt;&gt; -&gt;
        |              %% NULL
     1..|              decode_text_row_acc(Types, Rest, [null | Acc]);
        |          _ -&gt;
        |              %% Every thing except NULL
    55..|              {Text, Rest} = lenenc_str(Data),
    55..|              Term = decode_text(Type, Text),
    55..|              decode_text_row_acc(Types, Rest, [Term | Acc])
        |      end;
        |  decode_text_row_acc([], &lt;&lt;&gt;&gt;, Acc) -&gt;
    47..|      lists:reverse(Acc).
        |  
        |  %% @doc When receiving data in the text protocol, we get everything as binaries
        |  %% (except NULL). This function is used to parse these strings values.
        |  decode_text(_, null) -&gt;
        |      %% NULL is the only value not represented as a binary.
     1..|      null;
        |  decode_text(T, Text)
        |    when T == ?TYPE_TINY; T == ?TYPE_SHORT; T == ?TYPE_LONG; T == ?TYPE_LONGLONG;
        |         T == ?TYPE_INT24; T == ?TYPE_YEAR; T == ?TYPE_BIT -&gt;
        |      %% For BIT, do we want bitstring, int or binary?
    13..|      binary_to_integer(Text);
        |  decode_text(T, Text)
        |    when T == ?TYPE_DECIMAL; T == ?TYPE_NEWDECIMAL; T == ?TYPE_VARCHAR;
        |         T == ?TYPE_ENUM; T == ?TYPE_TINY_BLOB; T == ?TYPE_MEDIUM_BLOB;
        |         T == ?TYPE_LONG_BLOB; T == ?TYPE_BLOB; T == ?TYPE_VAR_STRING;
        |         T == ?TYPE_STRING; T == ?TYPE_GEOMETRY -&gt;
    17..|      Text;
        |  decode_text(?TYPE_DATE, &lt;&lt;Y:4/binary, "-", M:2/binary, "-", D:2/binary&gt;&gt;) -&gt;
     2..|      {binary_to_integer(Y), binary_to_integer(M), binary_to_integer(D)};
        |  decode_text(?TYPE_TIME, Text) -&gt;
    20..|      {match, [Sign, Hbin, Mbin, Sbin, Frac]} =
        |          re:run(Text,
        |                 &lt;&lt;"^(-?)(\\d+):(\\d+):(\\d+)(\\.?\\d*)$"&gt;&gt;,
        |                 [{capture, all_but_first, binary}]),
    20..|      H = binary_to_integer(Hbin),
    20..|      M = binary_to_integer(Mbin),
    20..|      S = binary_to_integer(Sbin),
    20..|      IsNeg = Sign == &lt;&lt;"-"&gt;&gt;,
    20..|      Fraction = case Frac of
    16..|          &lt;&lt;&gt;&gt; -&gt; 0;
     2..|          _ when not IsNeg -&gt; binary_to_float(&lt;&lt;"0", Frac/binary&gt;&gt;);
     2..|          _ when IsNeg -&gt; 1 - binary_to_float(&lt;&lt;"0", Frac/binary&gt;&gt;)
        |      end,
    20..|      Sec1 = H * 3600 + M * 60 + S,
    20..|      Sec2 = if IsNeg -&gt; -Sec1; true -&gt; Sec1 end,
    20..|      Sec3 = if IsNeg and (Fraction /= 0) -&gt; Sec2 - 1;
    18..|                true                      -&gt; Sec2
        |             end,
    20..|      {Days, {Hours, Minutes, Seconds}} = calendar:seconds_to_daystime(Sec3),
    20..|      {Days, {Hours, Minutes, Seconds + Fraction}};
        |  decode_text(T, &lt;&lt;Y:4/binary, "-", M:2/binary, "-", D:2/binary, " ",
        |                   H:2/binary, ":", Mi:2/binary, ":", S:2/binary&gt;&gt;)
        |    when T == ?TYPE_TIMESTAMP; T == ?TYPE_DATETIME -&gt;
        |      %% Without fractions.
     3..|      {{binary_to_integer(Y), binary_to_integer(M), binary_to_integer(D)},
        |       {binary_to_integer(H), binary_to_integer(Mi), binary_to_integer(S)}};
        |  decode_text(T, &lt;&lt;Y:4/binary, "-", M:2/binary, "-", D:2/binary, " ",
        |                   H:2/binary, ":", Mi:2/binary, ":", FloatS/binary&gt;&gt;)
        |    when T == ?TYPE_TIMESTAMP; T == ?TYPE_DATETIME -&gt;
        |      %% With fractions.
     1..|      {{binary_to_integer(Y), binary_to_integer(M), binary_to_integer(D)},
        |       {binary_to_integer(H), binary_to_integer(Mi), binary_to_float(FloatS)}};
        |  decode_text(T, Text) when T == ?TYPE_FLOAT; T == ?TYPE_DOUBLE -&gt;
    26..|      try binary_to_float(Text)
        |      catch error:badarg -&gt;
     9..|          try binary_to_integer(Text) of
     8..|              Int -&gt; float(Int)
        |          catch error:badarg -&gt;
        |              %% It is something like "4e75" that must be turned into "4.0e75"
     1..|              binary_to_float(binary:replace(Text, &lt;&lt;"e"&gt;&gt;, &lt;&lt;".0e"&gt;&gt;))
        |          end
        |      end;
        |  decode_text(?TYPE_SET, &lt;&lt;&gt;&gt;) -&gt;
     1..|      sets:new();
        |  decode_text(?TYPE_SET, Text) -&gt;
     1..|      sets:from_list(binary:split(Text, &lt;&lt;","&gt;&gt;, [global])).
        |  
        |  %% -- binary protocol --
        |  
        |  %% @doc If NumColumns is non-zero, fetches this number of column definitions
        |  %% and an EOF packet. Used by prepare/3.
        |  fetch_column_definitions_if_any(0, _RecvFun, SeqNum) -&gt;
     8..|      {[], SeqNum};
        |  fetch_column_definitions_if_any(N, RecvFun, SeqNum) -&gt;
    12..|      {ok, Defs, SeqNum1} = fetch_column_definitions(RecvFun, SeqNum, N, []),
    12..|      {ok, ?eof_pattern, SeqNum2} = recv_packet(RecvFun, SeqNum1),
    12..|      {Defs, SeqNum2}.
        |  
        |  %% @doc Decodes a packet representing a row in a binary result set.
        |  %% It consists of a 0 byte, then a null bitmap, then the values.
        |  %% Returns a list of length NumColumns with terms of appropriate types for each
        |  %% MySQL type in ColumnTypes.
        |  -spec decode_binary_row(NumColumns :: integer(), ColumnTypes :: [integer()],
        |                   Data :: binary()) -&gt; [term()].
        |  decode_binary_row(NumColumns, ColumnTypes, &lt;&lt;0, Data/binary&gt;&gt;) -&gt;
    41..|      {NullBitMap, Rest} = null_bitmap_decode(NumColumns, Data, 2),
    41..|      decode_binary_row_acc(ColumnTypes, NullBitMap, Rest, []).
        |  
        |  %% @doc Accumulating helper for decode_binary_row/3.
        |  decode_binary_row_acc([_ | Types], &lt;&lt;1:1, NullBitMap/bitstring&gt;&gt;, Data, Acc) -&gt;
        |      %% NULL
     1..|      decode_binary_row_acc(Types, NullBitMap, Data, [null | Acc]);
        |  decode_binary_row_acc([Type | Types], &lt;&lt;0:1, NullBitMap/bitstring&gt;&gt;, Data,
        |                        Acc) -&gt;
        |     %% Not NULL
    48..|     {Term, Rest} = decode_binary(Type, Data),
    48..|     decode_binary_row_acc(Types, NullBitMap, Rest, [Term | Acc]);
        |  decode_binary_row_acc([], _, &lt;&lt;&gt;&gt;, Acc) -&gt;
    41..|      lists:reverse(Acc).
        |  
        |  %% @doc Decodes a null bitmap as stored by MySQL and returns it in a strait
        |  %% bitstring counting bits from left to right in a tuple with remaining data.
        |  %%
        |  %% In the MySQL null bitmap the bits are stored counting bytes from the left and
        |  %% bits within each byte from the right. (Sort of little endian.)
        |  -spec null_bitmap_decode(NumColumns :: integer(), BitOffset :: integer(),
        |                           Data :: binary()) -&gt;
        |      {NullBitstring :: bitstring(), Rest :: binary()}.
        |  null_bitmap_decode(NumColumns, Data, BitOffset) -&gt;
        |      %% Binary shift right by 3 is equivallent to integer division by 8.
    42..|      BitMapLength = (NumColumns + BitOffset + 7) bsr 3,
    42..|      &lt;&lt;NullBitstring0:BitMapLength/binary, Rest/binary&gt;&gt; = Data,
    42..|      &lt;&lt;_:BitOffset, NullBitstring:NumColumns/bitstring, _/bitstring&gt;&gt; =
    44..|          &lt;&lt; &lt;&lt;(reverse_byte(B))/binary&gt;&gt; || &lt;&lt;B:1/binary&gt;&gt; &lt;= NullBitstring0 &gt;&gt;,
    42..|      {NullBitstring, Rest}.
        |  
        |  %% @doc The reverse of null_bitmap_decode/3. The number of columns is taken to
        |  %% be the number of bits in NullBitstring. Returns the MySQL null bitmap as a
        |  %% binary (i.e. full bytes). BitOffset is the number of unused bits that should
        |  %% be inserted before the other bits.
        |  -spec null_bitmap_encode(bitstring(), integer()) -&gt; binary().
        |  null_bitmap_encode(NullBitstring, BitOffset) -&gt;
    33..|      PayloadLength = bit_size(NullBitstring) + BitOffset,
        |      %% Round up to a multiple of 8.
    33..|      BitMapLength = (PayloadLength + 7) band bnot 7,
    33..|      PadBitsLength = BitMapLength - PayloadLength,
    33..|      PaddedBitstring = &lt;&lt;0:BitOffset, NullBitstring/bitstring, 0:PadBitsLength&gt;&gt;,
    33..|      &lt;&lt; &lt;&lt;(reverse_byte(B))/binary&gt;&gt; || &lt;&lt;B:1/binary&gt;&gt; &lt;= PaddedBitstring &gt;&gt;.
        |  
        |  %% Reverses the bits in a byte.
        |  reverse_byte(&lt;&lt;A:1, B:1, C:1, D:1, E:1, F:1, G:1, H:1&gt;&gt;) -&gt;
    78..|      &lt;&lt;H:1, G:1, F:1, E:1, D:1, C:1, B:1, A:1&gt;&gt;.
        |  
        |  %% @doc Used for executing prepared statements. The bit offset whould be 0 in
        |  %% this case.
        |  -spec build_null_bitmap([any()]) -&gt; binary().
        |  build_null_bitmap(Values) -&gt;
    32..|      Bits = &lt;&lt; &lt;&lt;(case V of null -&gt; 1; _ -&gt; 0 end):1&gt;&gt; || V &lt;- Values &gt;&gt;,
    32..|      null_bitmap_encode(Bits, 0).
        |  
        |  %% Decodes a value as received in the 'binary protocol' result set.
        |  %%
        |  %% The types are type constants for the binary protocol, such as
        |  %% ProtocolBinary::MYSQL_TYPE_STRING. In the guide "MySQL Internals" these are
        |  %% not listed, but we assume that are the same as for the text protocol.
        |  -spec decode_binary(Type :: integer(), Data :: binary()) -&gt;
        |      {Term :: term(), Rest :: binary()}.
        |  decode_binary(T, Data)
        |    when T == ?TYPE_STRING; T == ?TYPE_VARCHAR; T == ?TYPE_VAR_STRING;
        |         T == ?TYPE_ENUM; T == ?TYPE_SET; T == ?TYPE_LONG_BLOB;
        |         T == ?TYPE_MEDIUM_BLOB; T == ?TYPE_BLOB; T == ?TYPE_TINY_BLOB;
        |         T == ?TYPE_GEOMETRY; T == ?TYPE_BIT; T == ?TYPE_DECIMAL;
        |         T == ?TYPE_NEWDECIMAL -&gt;
     3..|      lenenc_str(Data);
        |  decode_binary(?TYPE_LONGLONG, &lt;&lt;Value:64/signed-little, Rest/binary&gt;&gt;) -&gt;
<font color=red>     0..|      {Value, Rest};</font>
        |  decode_binary(T, &lt;&lt;Value:32/signed-little, Rest/binary&gt;&gt;)
        |    when T == ?TYPE_LONG; T == ?TYPE_INT24 -&gt;
     1..|      {Value, Rest};
        |  decode_binary(T, &lt;&lt;Value:16/signed-little, Rest/binary&gt;&gt;)
        |    when T == ?TYPE_SHORT; T == ?TYPE_YEAR -&gt;
<font color=red>     0..|      {Value, Rest};</font>
        |  decode_binary(?TYPE_TINY, &lt;&lt;Value:8, Rest/binary&gt;&gt;) -&gt;
<font color=red>     0..|      {Value, Rest};</font>
        |  decode_binary(?TYPE_DOUBLE, &lt;&lt;Value:64/float-little, Rest/binary&gt;&gt;) -&gt;
<font color=red>     0..|      {Value, Rest};</font>
        |  decode_binary(?TYPE_FLOAT, &lt;&lt;Value:32/float-little, Rest/binary&gt;&gt;) -&gt;
        |      %% There is a precision loss when storing and fetching a 32-bit float.
        |      %% In the text protocol, it is obviously rounded. Storing 3.14 in a FLOAT
        |      %% column and fetching it using the text protocol, we get "3.14" which we
        |      %% parse to the Erlang double as close as possible to 3.14. Fetching the
        |      %% same value as a binary 32-bit float, we get 3.140000104904175. To achieve
        |      %% the same rounding after receiving it as a 32-bit float, we try to do the
        |      %% same rounding here as MySQL does when sending it over the text protocol.
        |      %%
        |      %% This comment explains the idea:
        |      %%
        |      %%     Posted by Geoffrey Downs on March 10 2011 10:26am
        |      %%
        |      %%     Following up... I *think* this is correct for the default float
        |      %%     columns in mysql:
        |      %%
        |      %%     var yourNumber = some floating point value
        |      %%     max decimal precision = 10 ^ (-5 + floor(yourNumber log 10))
        |      %%     So:
        |      %%     0 &lt; x &lt; 10 -&gt; max precision is 0.00001
        |      %%     10 &lt;= x &lt; 100 -&gt; max precision is 0.0001
        |      %%     100 &lt;= x &lt; 1000 -&gt; max precision is 0.001
        |      %%     etc.
        |      %%
        |      %% (From http://dev.mysql.com/doc/refman/5.7/en/problems-with-float.html
        |      %% fetched 10 Nov 2014)
        |      %%
        |      %% The above is almost correct, except for the example in the interval
        |      %% 0 &lt; x &lt; 1. There are 6 significant digits also for these numbers.
        |      %%
        |      %% Now, instead of P = 0.00001 we want the inverse 100000.0 but if we
        |      %% compute Factor = 1 / P we get a precision loss, so instead we do this:
    22..|      Factor = math:pow(10, floor(6 - math:log10(abs(Value)))),
    22..|      RoundedValue = round(Value * Factor) / Factor,
    22..|      {RoundedValue, Rest};
        |  decode_binary(?TYPE_DATE, &lt;&lt;Length, Data/binary&gt;&gt;) -&gt;
        |      %% Coded in the same way as DATETIME and TIMESTAMP below, but returned in
        |      %% a simple triple.
     1..|      case {Length, Data} of
<font color=red>     0..|          {0, _} -&gt; {{0, 0, 0}, Data};</font>
     1..|          {4, &lt;&lt;Y:16/little, M, D, Rest/binary&gt;&gt;} -&gt; {{Y, M, D}, Rest}
        |      end;
        |  decode_binary(T, &lt;&lt;Length, Data/binary&gt;&gt;)
        |    when T == ?TYPE_DATETIME; T == ?TYPE_TIMESTAMP -&gt;
        |      %% length (1) -- number of bytes following (valid values: 0, 4, 7, 11)
     2..|      case {Length, Data} of
        |          {0, _} -&gt;
<font color=red>     0..|              {{{0, 0, 0}, {0, 0, 0}}, Data};</font>
        |          {4, &lt;&lt;Y:16/little, M, D, Rest/binary&gt;&gt;} -&gt;
<font color=red>     0..|              {{{Y, M, D}, {0, 0, 0}}, Rest};</font>
        |          {7, &lt;&lt;Y:16/little, M, D, H, Mi, S, Rest/binary&gt;&gt;} -&gt;
     1..|              {{{Y, M, D}, {H, Mi, S}}, Rest};
        |          {11, &lt;&lt;Y:16/little, M, D, H, Mi, S, Micro:32/little, Rest/binary&gt;&gt;} -&gt;
     1..|              {{{Y, M, D}, {H, Mi, S + 0.000001 * Micro}}, Rest}
        |      end;
        |  decode_binary(?TYPE_TIME, &lt;&lt;Length, Data/binary&gt;&gt;) -&gt;
        |      %% length (1) -- number of bytes following (valid values: 0, 8, 12)
        |      %% is_negative (1) -- (1 if minus, 0 for plus)
        |      %% days (4) -- days
        |      %% hours (1) -- hours
        |      %% minutes (1) -- minutes
        |      %% seconds (1) -- seconds
        |      %% micro_seconds (4) -- micro-seconds
    19..|      case {Length, Data} of
        |          {0, _} -&gt;
<font color=red>     0..|              {{0, {0, 0, 0}}, Data};</font>
        |          {8, &lt;&lt;0, D:32/little, H, M, S, Rest/binary&gt;&gt;} -&gt;
     5..|              {{D, {H, M, S}}, Rest};
        |          {12, &lt;&lt;0, D:32/little, H, M, S, Micro:32/little, Rest/binary&gt;&gt;} -&gt;
     2..|              {{D, {H, M, S + 0.000001 * Micro}}, Rest};
        |          {8, &lt;&lt;1, D:32/little, H, M, S, Rest/binary&gt;&gt;} -&gt;
        |              %% Negative time. Example: '-00:00:01' --&gt; {-1,{23,59,59}}
    10..|              Seconds = ((D * 24 + H) * 60 + M) * 60 + S,
        |              %Seconds = D * 86400 + calendar:time_to_seconds({H, M, S}),
    10..|              {calendar:seconds_to_daystime(-Seconds), Rest};
        |          {12, &lt;&lt;1, D:32/little, H, M, S, Micro:32/little, Rest/binary&gt;&gt;}
        |            when Micro &gt; 0 -&gt;
        |              %% Negate and convert to seconds, excl fractions
     2..|              Seconds = -(((D * 24 + H) * 60 + M) * 60 + S),
        |              %Seconds = -D * 86400 - calendar:time_to_seconds({H, M, S}),
        |              %% Subtract 1 second for the fractions
     2..|              {Days, {Hours, Minutes, Sec}} =
        |                  calendar:seconds_to_daystime(Seconds - 1),
        |              %% Adding the fractions to Sec again makes it a float
     2..|              {{Days, {Hours, Minutes, Sec + 1 - 0.000001 * Micro}}, Rest}
        |      end.
        |  
        |  %% @doc Like trunc/1 but towards negative infinity instead of towards zero.
        |  floor(Value) -&gt;
    22..|      Trunc = trunc(Value),
    22..|      if
    16..|          Trunc =&lt; Value -&gt; Trunc;
     6..|          Trunc &gt; Value -&gt; Trunc - 1 %% for negative values
        |      end.
        |  
        |  %% @doc Encodes a term reprenting av value as a binary for use in the binary
        |  %% protocol. As this is used to encode parameters for prepared statements, the
        |  %% encoding is in its required form, namely `&lt;&lt;Type:8, Sign:8, Value/binary&gt;&gt;'.
        |  %%
        |  %% TODO: Maybe change Erlang representation of BIT to `&lt;&lt;_:1&gt;&gt;'.
        |  -spec encode_param(term()) -&gt; {TypeAndSign :: binary(), Data :: binary()}.
        |  encode_param(null) -&gt;
     1..|      {&lt;&lt;?TYPE_NULL, 0&gt;&gt;, &lt;&lt;&gt;&gt;};
        |  encode_param(Value) when is_binary(Value) -&gt;
     2..|      EncLength = lenenc_int_encode(byte_size(Value)),
     2..|      {&lt;&lt;?TYPE_VAR_STRING, 0&gt;&gt;, &lt;&lt;EncLength/binary, Value/binary&gt;&gt;};
        |  encode_param(Value) when is_integer(Value), Value &gt;= 0 -&gt;
        |      %% We send positive integers with the 'unsigned' flag set.
     1..|      if
        |          Value =&lt; 16#ff -&gt;
     1..|              {&lt;&lt;?TYPE_TINY, 16#80&gt;&gt;, &lt;&lt;Value:8&gt;&gt;};
        |          Value =&lt; 16#ffff -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_SHORT, 16#80&gt;&gt;, &lt;&lt;Value:16/little&gt;&gt;};</font>
        |          Value =&lt; 16#ffffffff -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_LONG, 16#80&gt;&gt;, &lt;&lt;Value:32/little&gt;&gt;};</font>
        |          Value =&lt; 16#ffffffffffffffff -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_LONGLONG, 16#80&gt;&gt;, &lt;&lt;Value:64/little&gt;&gt;};</font>
        |          true -&gt;
        |              %% If larger than a 64-bit int we send it as a string. MySQL does
        |              %% silently cast strings in aithmetic expressions. Also, DECIMALs
        |              %% are always sent as strings.
<font color=red>     0..|              encode_param(integer_to_binary(Value))</font>
        |      end;
        |  encode_param(Value) when is_integer(Value), Value &lt; 0 -&gt;
<font color=red>     0..|      if</font>
        |          Value &gt;= -16#80 -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_TINY, 0&gt;&gt;, &lt;&lt;Value:8&gt;&gt;};</font>
        |          Value &gt;= -16#8000 -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_SHORT, 0&gt;&gt;, &lt;&lt;Value:16/little&gt;&gt;};</font>
        |          Value &gt;= -16#80000000 -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_LONG, 0&gt;&gt;, &lt;&lt;Value:32/little&gt;&gt;};</font>
        |          Value &gt;= -16#8000000000000000 -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_LONGLONG, 0&gt;&gt;, &lt;&lt;Value:64/little&gt;&gt;};</font>
        |          true -&gt;
<font color=red>     0..|              encode_param(integer_to_binary(Value))</font>
        |      end;
        |  encode_param(Value) when is_float(Value) -&gt;
    22..|      {&lt;&lt;?TYPE_DOUBLE, 0&gt;&gt;, &lt;&lt;Value:64/float-little&gt;&gt;};
        |  encode_param({Y, M, D}) -&gt;
        |      %% calendar:date()
     1..|      {&lt;&lt;?TYPE_DATE, 0&gt;&gt;, &lt;&lt;4, Y:16/little, M, D&gt;&gt;};
        |  encode_param({{Y, M, D}, {0, 0, 0}}) -&gt;
        |      %% Datetime at midnight
<font color=red>     0..|      {&lt;&lt;?TYPE_DATETIME, 0&gt;&gt;, &lt;&lt;4, Y:16/little, M, D&gt;&gt;};</font>
        |  encode_param({{Y, M, D}, {H, Mi, S}}) when is_integer(S) -&gt;
        |      %% calendar:datetime()
     1..|      {&lt;&lt;?TYPE_DATETIME, 0&gt;&gt;, &lt;&lt;7, Y:16/little, M, D, H, Mi, S&gt;&gt;};
        |  encode_param({{Y, M, D}, {H, Mi, S}}) when is_float(S) -&gt;
        |      %% calendar:datetime() with a float for seconds. This way it looks very
        |      %% similar to a datetime. Microseconds in MySQL timestamps are possible but
        |      %% not very common.
<font color=red>     0..|      Sec = trunc(S),</font>
<font color=red>     0..|      Micro = round(1000000 * (S - Sec)),</font>
<font color=red>     0..|      {&lt;&lt;?TYPE_DATETIME, 0&gt;&gt;, &lt;&lt;11, Y:16/little, M, D, H, Mi, Sec,</font>
        |                                Micro:32/little&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_integer(S), D &gt;= 0 -&gt;
        |      %% calendar:seconds_to_daystime()
     3..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;8, 0, D:32/little, H, M, S&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_integer(S), D &lt; 0 -&gt;
        |      %% Convert to seconds, negate and convert back to daystime form.
        |      %% Then set the minus flag.
     5..|      Seconds = ((D * 24 + H) * 60 + M) * 60 + S,
     5..|      {D1, {H1, M1, S1}} = calendar:seconds_to_daystime(-Seconds),
     5..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;8, 1, D1:32/little, H1, M1, S1&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_float(S), D &gt;= 0 -&gt;
     1..|      S1 = trunc(S),
     1..|      Micro = round(1000000 * (S - S1)),
     1..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;12, 0, D:32/little, H, M, S1, Micro:32/little&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_float(S), S &gt; 0.0, D &lt; 0 -&gt;
     1..|      IntS = trunc(S),
     1..|      Micro = round(1000000 * (1 - S + IntS)),
     1..|      Seconds = (D * 24 + H) * 3600 + M * 60 + IntS + 1,
     1..|      {D1, {M1, H1, S1}} = calendar:seconds_to_daystime(-Seconds),
     1..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;12, 1, D1:32/little, H1, M1, S1, Micro:32/little&gt;&gt;};
        |  encode_param({D, {H, M, 0.0}}) -&gt;
<font color=red>     0..|      encode_param({D, {H, M, 0}}).</font>
        |  
        |  %% -- Protocol basics: packets --
        |  
        |  %% @doc Wraps Data in packet headers, sends it by calling SendFun and returns
        |  %% {ok, SeqNum1} where SeqNum1 is the next sequence number.
        |  -spec send_packet(sendfun(), Data :: binary(), SeqNum :: integer()) -&gt;
        |      {ok, NextSeqNum :: integer()}.
        |  send_packet(SendFun, Data, SeqNum) -&gt;
   218..|      {WithHeaders, SeqNum1} = add_packet_headers(Data, SeqNum),
   218..|      ok = SendFun(WithHeaders),
   218..|      {ok, SeqNum1}.
        |  
        |  %% @doc Receives data by calling RecvFun and removes the packet headers. Returns
        |  %% the packet contents and the next packet sequence number.
        |  -spec recv_packet(RecvFun :: recvfun(), SeqNum :: integer()) -&gt;
        |      {ok, Data :: binary(), NextSeqNum :: integer()}.
        |  recv_packet(RecvFun, SeqNum) -&gt;
   641..|      recv_packet(RecvFun, SeqNum, &lt;&lt;&gt;&gt;).
        |  
        |  %% @doc Receives data by calling RecvFun and removes packet headers. Returns the
        |  %% data and the next packet sequence number.
        |  -spec recv_packet(RecvFun :: recvfun(), ExpectSeqNum :: integer(),
        |                    Acc :: binary()) -&gt;
        |      {ok, Data :: binary(), NextSeqNum :: integer()}.
        |  recv_packet(RecvFun, ExpectSeqNum, Acc) -&gt;
   641..|      {ok, Header} = RecvFun(4),
   641..|      {Size, ExpectSeqNum, More} = parse_packet_header(Header),
   641..|      {ok, Body} = RecvFun(Size),
   641..|      Acc1 = &lt;&lt;Acc/binary, Body/binary&gt;&gt;,
   641..|      NextSeqNum = (ExpectSeqNum + 1) band 16#ff,
   641..|      case More of
   641..|          false -&gt; {ok, Acc1, NextSeqNum};
<font color=red>     0..|          true  -&gt; recv_packet(RecvFun, NextSeqNum, Acc1)</font>
        |      end.
        |  
        |  %% @doc Parses a packet header (32 bits) and returns a tuple.
        |  %%
        |  %% The client should first read a header and parse it. Then read PacketLength
        |  %% bytes. If there are more packets, read another header and read a new packet
        |  %% length of payload until there are no more packets. The seq num should
        |  %% increment from 0 and may wrap around at 255 back to 0.
        |  %%
        |  %% When all packets are read and the payload of all packets are concatenated, it
        |  %% can be parsed using parse_response/1, etc. depending on what type of response
        |  %% is expected.
        |  -spec parse_packet_header(PackerHeader :: binary()) -&gt;
        |      {PacketLength :: integer(),
        |       SeqNum :: integer(),
        |       MorePacketsExist :: boolean()}.
        |  parse_packet_header(&lt;&lt;PacketLength:24/little-integer, SeqNum:8/integer&gt;&gt;) -&gt;
   642..|      {PacketLength, SeqNum, PacketLength == 16#ffffff}.
        |  
        |  %% @doc Splits a packet body into chunks and wraps them in headers. The
        |  %% resulting list is ready to sent to the socket.
        |  -spec add_packet_headers(PacketBody :: iodata(), SeqNum :: integer()) -&gt;
        |      {PacketWithHeaders :: iodata(), NextSeqNum :: integer()}.
        |  add_packet_headers(PacketBody, SeqNum) -&gt;
   219..|      Bin = iolist_to_binary(PacketBody),
   219..|      Size = size(Bin),
   219..|      SeqNum1 = (SeqNum + 1) rem 16#100,
        |      %% Todo: implement the case when Size &gt;= 16#ffffff.
   219..|      if Size &lt; 16#ffffff -&gt;
   219..|          {[&lt;&lt;Size:24/little, SeqNum:8&gt;&gt;, Bin], SeqNum1}
        |      end.
        |  
        |  -spec parse_ok_packet(binary()) -&gt; #ok{}.
        |  parse_ok_packet(&lt;&lt;?OK:8, Rest/binary&gt;&gt;) -&gt;
   119..|      {AffectedRows, Rest1} = lenenc_int(Rest),
   119..|      {InsertId, Rest2} = lenenc_int(Rest1),
   119..|      &lt;&lt;StatusFlags:16/little, WarningCount:16/little, Msg/binary&gt;&gt; = Rest2,
        |      %% We have CLIENT_PROTOCOL_41 but not CLIENT_SESSION_TRACK enabled. The
        |      %% protocol is conditional. This is from the protocol documentation:
        |      %%
        |      %% if capabilities &amp; CLIENT_PROTOCOL_41 {
        |      %%   int&lt;2&gt; status_flags
        |      %%   int&lt;2&gt; warning_count
        |      %% } elseif capabilities &amp; CLIENT_TRANSACTIONS {
        |      %%   int&lt;2&gt; status_flags
        |      %% }
        |      %% if capabilities &amp; CLIENT_SESSION_TRACK {
        |      %%   string&lt;lenenc&gt; info
        |      %%   if status_flags &amp; SERVER_SESSION_STATE_CHANGED {
        |      %%     string&lt;lenenc&gt; session_state_changes
        |      %%   }
        |      %% } else {
        |      %%   string&lt;EOF&gt; info
        |      %% }
   119..|      #ok{affected_rows = AffectedRows,
        |          insert_id = InsertId,
        |          status = StatusFlags,
        |          warning_count = WarningCount,
        |          msg = Msg}.
        |  
        |  -spec parse_error_packet(binary()) -&gt; #error{}.
        |  parse_error_packet(&lt;&lt;?ERROR:8, ErrNo:16/little, "#", SQLState:5/binary-unit:8,
        |                       Msg/binary&gt;&gt;) -&gt;
        |      %% Error, 4.1 protocol.
        |      %% (Older protocol: &lt;&lt;?ERROR:8, ErrNo:16/little, Msg/binary&gt;&gt;)
     3..|      #error{code = ErrNo, state = SQLState, msg = Msg}.
        |  
        |  -spec parse_eof_packet(binary()) -&gt; #eof{}.
        |  parse_eof_packet(&lt;&lt;?EOF:8, NumWarnings:16/little, StatusFlags:16/little&gt;&gt;) -&gt;
        |      %% EOF packet, 4.1 protocol.
        |      %% (Older protocol: &lt;&lt;?EOF:8&gt;&gt;)
    90..|      #eof{status = StatusFlags, warning_count = NumWarnings}.
        |  
        |  -spec hash_password(Password :: iodata(), Salt :: binary()) -&gt; Hash :: binary().
        |  hash_password(Password, Salt) -&gt;
        |      %% From the "MySQL Internals" manual:
        |      %% SHA1( password ) XOR SHA1( "20-bytes random data from server" &lt;concat&gt;
        |      %%                            SHA1( SHA1( password ) ) )
        |      %% ----
        |      %% Make sure the salt is exactly 20 bytes.
        |      %%
        |      %% The auth data is obviously nul-terminated. For the "native" auth
        |      %% method, it should be a 20 byte salt, so let's trim it in this case.
     4..|      Salt1 = case Salt of
     3..|          &lt;&lt;SaltNoNul:20/binary-unit:8, 0&gt;&gt; -&gt; SaltNoNul;
     1..|          _ when size(Salt) == 20           -&gt; Salt
        |      end,
        |      %% Hash as described above.
     4..|      &lt;&lt;Hash1Num:160&gt;&gt; = Hash1 = crypto:hash(sha, Password),
     4..|      Hash2 = crypto:hash(sha, Hash1),
     4..|      &lt;&lt;Hash3Num:160&gt;&gt; = crypto:hash(sha, &lt;&lt;Salt1/binary, Hash2/binary&gt;&gt;),
     4..|      &lt;&lt;(Hash1Num bxor Hash3Num):160&gt;&gt;.
        |  
        |  %% --- Lowlevel: variable length integers and strings ---
        |  
        |  %% lenenc_int/1 decodes length-encoded-integer values
        |  -spec lenenc_int(Input :: binary()) -&gt; {Value :: integer(), Rest :: binary()}.
  1381..|  lenenc_int(&lt;&lt;Value:8, Rest/bits&gt;&gt;) when Value &lt; 251 -&gt; {Value, Rest};
     1..|  lenenc_int(&lt;&lt;16#fc:8, Value:16/little, Rest/binary&gt;&gt;) -&gt; {Value, Rest};
     1..|  lenenc_int(&lt;&lt;16#fd:8, Value:24/little, Rest/binary&gt;&gt;) -&gt; {Value, Rest};
     1..|  lenenc_int(&lt;&lt;16#fe:8, Value:64/little, Rest/binary&gt;&gt;) -&gt; {Value, Rest}.
        |  
        |  %% Length-encoded-integer encode. Appends the encoded value to Acc.
        |  %% Values not representable in 64 bits are not accepted.
        |  -spec lenenc_int_encode(0..16#ffffffffffffffff) -&gt; binary().
        |  lenenc_int_encode(Value) when Value &lt; 0 -&gt;
<font color=red>     0..|      error(badarg);</font>
        |  lenenc_int_encode(Value) when Value &lt; 251 -&gt;
     3..|      &lt;&lt;Value&gt;&gt;;
        |  lenenc_int_encode(Value) when Value =&lt; 16#ffff -&gt;
     1..|      &lt;&lt;16#fc, Value:16/little&gt;&gt;;
        |  lenenc_int_encode(Value) when Value =&lt; 16#ffffff -&gt;
     1..|      &lt;&lt;16#fd, Value:24/little&gt;&gt;;
        |  lenenc_int_encode(Value) when Value =&lt; 16#ffffffffffffffff -&gt;
     1..|      &lt;&lt;16#fe, Value:64/little&gt;&gt;.
        |  
        |  %% lenenc_str/1 decodes length-encoded-string values
        |  -spec lenenc_str(Input :: binary()) -&gt; {String :: binary(), Rest :: binary()}.
        |  lenenc_str(Bin) -&gt;
   911..|      {Length, Rest} = lenenc_int(Bin),
   911..|      &lt;&lt;String:Length/binary, Rest1/binary&gt;&gt; = Rest,
   911..|      {String, Rest1}.
        |  
        |  %% nts/1 decodes a nul-terminated string
        |  -spec nulterm_str(Input :: binary()) -&gt; {String :: binary(), Rest :: binary()}.
        |  nulterm_str(Bin) -&gt;
     4..|      [String, Rest] = binary:split(Bin, &lt;&lt;0&gt;&gt;),
     4..|      {String, Rest}.
        |  
        |  -ifdef(TEST).
        |  -include_lib("eunit/include/eunit.hrl").
        |  -include("server_status.hrl").
        |  
        |  %% Testing some of the internal functions, mostly the cases we don't cover in
        |  %% other tests.
        |  
        |  decode_text_test() -&gt;
        |      %% Int types
     1..|      lists:foreach(fun (T) -&gt; ?assertEqual(1, decode_text(T, &lt;&lt;"1"&gt;&gt;)) end,
        |                    [?TYPE_TINY, ?TYPE_SHORT, ?TYPE_LONG, ?TYPE_LONGLONG,
        |                     ?TYPE_INT24, ?TYPE_YEAR, ?TYPE_BIT]),
        |  
        |      %% Floating point and decimal numbers
     1..|      lists:foreach(fun (T) -&gt; ?assertEqual(3.0, decode_text(T, &lt;&lt;"3.0"&gt;&gt;)) end,
        |                    [?TYPE_FLOAT, ?TYPE_DOUBLE]),
        |      %% Decimal types
     1..|      lists:foreach(fun (T) -&gt;
     2..|                        ?assertEqual(&lt;&lt;"3.0"&gt;&gt;, decode_text(T, &lt;&lt;"3.0"&gt;&gt;))
        |                    end,
        |                    [?TYPE_DECIMAL, ?TYPE_NEWDECIMAL]),
     1..|      ?assertEqual(3.0,  decode_text(?TYPE_FLOAT, &lt;&lt;"3"&gt;&gt;)),
     1..|      ?assertEqual(30.0, decode_text(?TYPE_FLOAT, &lt;&lt;"3e1"&gt;&gt;)),
     1..|      ?assertEqual(3,    decode_text(?TYPE_LONG, &lt;&lt;"3"&gt;&gt;)),
        |  
        |      %% Date and time
     1..|      ?assertEqual({2014, 11, 01}, decode_text(?TYPE_DATE, &lt;&lt;"2014-11-01"&gt;&gt;)),
     1..|      ?assertEqual({0, {23, 59, 01}}, decode_text(?TYPE_TIME, &lt;&lt;"23:59:01"&gt;&gt;)),
     1..|      ?assertEqual({{2014, 11, 01}, {23, 59, 01}},
     1..|                   decode_text(?TYPE_DATETIME, &lt;&lt;"2014-11-01 23:59:01"&gt;&gt;)),
     1..|      ?assertEqual({{2014, 11, 01}, {23, 59, 01}},
     1..|                   decode_text(?TYPE_TIMESTAMP, &lt;&lt;"2014-11-01 23:59:01"&gt;&gt;)),
        |  
        |      %% Strings and blobs
     1..|      lists:foreach(fun (T) -&gt;
     9..|                        ?assertEqual(&lt;&lt;"x"&gt;&gt;, decode_text(T, &lt;&lt;"x"&gt;&gt;))
        |                    end,
        |                    [?TYPE_VARCHAR, ?TYPE_ENUM, ?TYPE_TINY_BLOB,
        |                     ?TYPE_MEDIUM_BLOB, ?TYPE_LONG_BLOB, ?TYPE_BLOB,
        |                     ?TYPE_VAR_STRING, ?TYPE_STRING, ?TYPE_GEOMETRY]),
        |  
        |      %% Set
     1..|      ?assertEqual(sets:from_list([&lt;&lt;"b"&gt;&gt;, &lt;&lt;"a"&gt;&gt;]),
     1..|                   decode_text(?TYPE_SET, &lt;&lt;"a,b"&gt;&gt;)),
     1..|      ?assertEqual(sets:from_list([]), decode_text(?TYPE_SET, &lt;&lt;&gt;&gt;)),
        |  
        |      %% NULL
     1..|      ?assertEqual(null, decode_text(?TYPE_FLOAT, null)),
     1..|      ok.
        |  
        |  decode_binary_test() -&gt;
        |      %% Test the special rounding we apply to (single precision) floats.
        |      %?assertEqual({1.0, &lt;&lt;&gt;&gt;},
        |      %             decode_binary(?TYPE_FLOAT, &lt;&lt;1.0:32/float-little&gt;&gt;)),
        |      %?assertEqual({0.2, &lt;&lt;&gt;&gt;},
        |      %             decode_binary(?TYPE_FLOAT, &lt;&lt;0.2:32/float-little&gt;&gt;)),
        |      %?assertEqual({-33.3333, &lt;&lt;&gt;&gt;},
        |      %             decode_binary(?TYPE_FLOAT, &lt;&lt;-33.333333:32/float-little&gt;&gt;)),
        |      %?assertEqual({0.000123457, &lt;&lt;&gt;&gt;},
        |      %             decode_binary(?TYPE_FLOAT, &lt;&lt;0.00012345678:32/float-little&gt;&gt;)),
        |      %?assertEqual({1234.57, &lt;&lt;&gt;&gt;},
        |      %             decode_binary(?TYPE_FLOAT, &lt;&lt;1234.56789:32/float-little&gt;&gt;)),
     1..|      ok.
        |  
        |  null_bitmap_test() -&gt;
     1..|      ?assertEqual({&lt;&lt;0, 1:1&gt;&gt;, &lt;&lt;&gt;&gt;}, null_bitmap_decode(9, &lt;&lt;0, 4&gt;&gt;, 2)),
     1..|      ?assertEqual(&lt;&lt;0, 4&gt;&gt;, null_bitmap_encode(&lt;&lt;0, 1:1&gt;&gt;, 2)),
     1..|      ok.
        |  
        |  lenenc_int_test() -&gt;
        |      %% decode
     1..|      ?assertEqual({40, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;40&gt;&gt;)),
     1..|      ?assertEqual({16#ff, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;16#fc, 255, 0&gt;&gt;)),
     1..|      ?assertEqual({16#33aaff, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;16#fd, 16#ff, 16#aa, 16#33&gt;&gt;)),
     1..|      ?assertEqual({16#12345678, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;16#fe, 16#78, 16#56, 16#34,
     1..|                                                   16#12, 0, 0, 0, 0&gt;&gt;)),
        |      %% encode
     1..|      ?assertEqual(&lt;&lt;40&gt;&gt;, lenenc_int_encode(40)),
     1..|      ?assertEqual(&lt;&lt;16#fc, 255, 0&gt;&gt;, lenenc_int_encode(255)),
     1..|      ?assertEqual(&lt;&lt;16#fd, 16#ff, 16#aa, 16#33&gt;&gt;,
     1..|                   lenenc_int_encode(16#33aaff)),
     1..|      ?assertEqual(&lt;&lt;16#fe, 16#78, 16#56, 16#34, 16#12, 0, 0, 0, 0&gt;&gt;,
     1..|                   lenenc_int_encode(16#12345678)),
     1..|      ok.
        |  
        |  lenenc_str_test() -&gt;
     1..|      ?assertEqual({&lt;&lt;"Foo"&gt;&gt;, &lt;&lt;"bar"&gt;&gt;}, lenenc_str(&lt;&lt;3, "Foobar"&gt;&gt;)).
        |  
        |  nulterm_test() -&gt;
     1..|      ?assertEqual({&lt;&lt;"Foo"&gt;&gt;, &lt;&lt;"bar"&gt;&gt;}, nulterm_str(&lt;&lt;"Foo", 0, "bar"&gt;&gt;)).
        |  
        |  parse_header_test() -&gt;
        |      %% Example from "MySQL Internals", revision 307, section 14.1.3.3 EOF_Packet
     1..|      Packet = &lt;&lt;16#05, 16#00, 16#00, 16#05, 16#fe, 16#00, 16#00, 16#02, 16#00&gt;&gt;,
     1..|      &lt;&lt;Header:4/binary-unit:8, Body/binary&gt;&gt; = Packet,
        |      %% Check header contents and body length
     1..|      ?assertEqual({size(Body), 5, false}, parse_packet_header(Header)),
     1..|      ok.
        |  
        |  add_packet_headers_test() -&gt;
     1..|      {Data, 43} = add_packet_headers(&lt;&lt;"foo"&gt;&gt;, 42),
     1..|      ?assertEqual(&lt;&lt;3, 0, 0, 42, "foo"&gt;&gt;, list_to_binary(Data)).
        |  
        |  parse_ok_test() -&gt;
     1..|      Body = &lt;&lt;0, 5, 1, 2, 0, 0, 0, "Foo"&gt;&gt;,
     1..|      ?assertEqual(#ok{affected_rows = 5,
        |                       insert_id = 1,
        |                       status = ?SERVER_STATUS_AUTOCOMMIT,
        |                       warning_count = 0,
        |                       msg = &lt;&lt;"Foo"&gt;&gt;},
     1..|                   parse_ok_packet(Body)).
        |  
        |  parse_error_test() -&gt;
        |      %% Protocol 4.1
     1..|      Body = &lt;&lt;255, 42, 0, "#", "XYZxx", "Foo"&gt;&gt;,
     1..|      ?assertEqual(#error{code = 42, state = &lt;&lt;"XYZxx"&gt;&gt;, msg = &lt;&lt;"Foo"&gt;&gt;},
     1..|                   parse_error_packet(Body)),
     1..|      ok.
        |  
        |  parse_eof_test() -&gt;
        |      %% Example from "MySQL Internals", revision 307, section 14.1.3.3 EOF_Packet
     1..|      Packet = &lt;&lt;16#05, 16#00, 16#00, 16#05, 16#fe, 16#00, 16#00, 16#02, 16#00&gt;&gt;,
     1..|      &lt;&lt;_Header:4/binary-unit:8, Body/binary&gt;&gt; = Packet,
        |      %% Ignore header. Parse body as an eof_packet.
     1..|      ?assertEqual(#eof{warning_count = 0,
        |                        status = ?SERVER_STATUS_AUTOCOMMIT},
     1..|                   parse_eof_packet(Body)),
     1..|      ok.
        |  
        |  hash_password_test() -&gt;
     1..|      ?assertEqual(&lt;&lt;222,207,222,139,41,181,202,13,191,241,
        |                     234,234,73,127,244,101,205,3,28,251&gt;&gt;,
     1..|                   hash_password(&lt;&lt;"foo"&gt;&gt;, &lt;&lt;"abcdefghijklmnopqrst"&gt;&gt;)).
        |  
        |  -endif.
</pre>
</body>
</html>
