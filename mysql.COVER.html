<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>.eunit/mysql.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /Users/viktor/data/mysql-otp/.eunit/mysql.erl by COVER 2014-12-10 at 23:00:16

****************************************************************************

        |  %% MySQL/OTP – MySQL client library for Erlang/OTP
        |  %% Copyright (C) 2014 Viktor Söderqvist
        |  %%
        |  %% This file is part of MySQL/OTP.
        |  %%
        |  %% MySQL/OTP is free software: you can redistribute it and/or modify it under
        |  %% the terms of the GNU Lesser General Public License as published by the Free
        |  %% Software Foundation, either version 3 of the License, or (at your option)
        |  %% any later version.
        |  %%
        |  %% This program is distributed in the hope that it will be useful, but WITHOUT
        |  %% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
        |  %% FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
        |  %% more details.
        |  %%
        |  %% You should have received a copy of the GNU Lesser General Public License
        |  %% along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
        |  
        |  %% @doc MySQL client.
        |  %%
        |  %% The `connection()' type is a gen_server reference as described in the
        |  %% documentation for `gen_server:call/2,3', e.g. the pid or the name if the
        |  %% gen_server is locally registered.
        |  -module(mysql).
        |  
        |  -export([start_link/1, query/2, query/3, execute/3,
        |           prepare/2, prepare/3, unprepare/2,
        |           warning_count/1, affected_rows/1, autocommit/1, insert_id/1,
        |           in_transaction/1,
        |           transaction/2, transaction/3]).
        |  
        |  -export_type([connection/0, server_reason/0]).
        |  
        |  -behaviour(gen_server).
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,
        |           code_change/3]).
        |  
        |  -define(default_host, "localhost").
        |  -define(default_port, 3306).
        |  -define(default_user, &lt;&lt;&gt;&gt;).
        |  -define(default_password, &lt;&lt;&gt;&gt;).
        |  -define(default_timeout, infinity).
        |  -define(default_query_cache_time, 60000). %% for query/3.
        |  
        |  %% A connection is a ServerRef as in gen_server:call/2,3.
        |  -type connection() :: Name :: atom() |
        |                        {Name :: atom(), Node :: atom()} |
        |                        {global, GlobalName :: term()} |
        |                        {via, Module :: atom(), ViaName :: term()} |
        |                        pid().
        |  
        |  %% MySQL error with the codes and message returned from the server.
        |  -type server_reason() :: {Code :: integer(), SQLState :: binary(),
        |                            Message :: binary()}.
        |  
        |  %% @doc Starts a connection gen_server process and connects to a database. To
        |  %% disconnect just do `exit(Pid, normal)'.
        |  %%
        |  %% Options:
        |  %%
        |  %% &lt;dl&gt;
        |  %%   &lt;dt&gt;`{name, ServerName}'&lt;/dt&gt;
        |  %%   &lt;dd&gt;If a name is provided, the gen_server will be registered with this
        |  %%       name. For details see the documentation for the first argument of
        |  %%       gen_server:start_link/4.&lt;/dd&gt;
        |  %%   &lt;dt&gt;`{host, Host}'&lt;/dt&gt;
        |  %%   &lt;dd&gt;Hostname of the MySQL database; default `"localhost"'.&lt;/dd&gt;
        |  %%   &lt;dt&gt;`{port, Port}'&lt;/dt&gt;
        |  %%   &lt;dd&gt;Port; default 3306 if omitted.&lt;/dd&gt;
        |  %%   &lt;dt&gt;`{user, User}'&lt;/dt&gt;
        |  %%   &lt;dd&gt;Username.&lt;/dd&gt;
        |  %%   &lt;dt&gt;`{password, Password}'&lt;/dt&gt;
        |  %%   &lt;dd&gt;Password.&lt;/dd&gt;
        |  %%   &lt;dt&gt;`{database, Database}'&lt;/dt&gt;
        |  %%   &lt;dd&gt;The name of the database AKA schema to use. This can be changed later
        |  %%       using the query `USE &lt;database&gt;'.&lt;/dd&gt;
        |  %%   &lt;dt&gt;`{query_cache_time, Timeout}'&lt;/dt&gt;
        |  %%   &lt;dd&gt;The minimum number of milliseconds to cache prepared statements used
        |  %%       for parametrized queries with query/3.&lt;/dd&gt;
        |  %% &lt;/dl&gt;
        |  -spec start_link(Options) -&gt; {ok, pid()} | ignore | {error, term()}
        |      when Options :: [Option],
        |           Option :: {name, ServerName} | {host, iodata()} | {port, integer()} | 
        |                     {user, iodata()} | {password, iodata()} |
        |                     {database, iodata()} |
        |                     {query_cache_time, non_neg_integer()},
        |           ServerName :: {local, Name :: atom()} |
        |                         {global, GlobalName :: term()} |
        |                         {via, Module :: atom(), ViaName :: term()}.
        |  start_link(Options) -&gt;
     4..|      case proplists:get_value(name, Options) of
        |          undefined -&gt;
     3..|              gen_server:start_link(?MODULE, Options, []);
        |          ServerName -&gt;
     1..|              gen_server:start_link(ServerName, ?MODULE, Options, [])
        |      end.
        |  
        |  %% @doc Executes a query.
        |  -spec query(Conn, Query) -&gt; ok | {ok, ColumnNames, Rows} | {error, Reason}
        |      when Conn :: connection(),
        |           Query :: iodata(),
        |           ColumnNames :: [binary()],
        |           Rows :: [[term()]],
        |           Reason :: server_reason().
        |  query(Conn, Query) -&gt;
   231..|      gen_server:call(Conn, {query, Query}).
        |  
        |  %% @doc Executes a parameterized query. A prepared statement is created,
        |  %% executed and then cached for a certain time. If the same query is executed
        |  %% again when it is already cached, it does not need to be prepared again.
        |  %%
        |  %% The minimum time the prepared statement is cached can be specified using the
        |  %% option `{query_cache_time, Milliseconds}' to start_link/1.
        |  -spec query(Conn, Query, Params) -&gt; ok | {ok, ColumnNames, Rows} |
        |                                      {error, Reason}
        |      when Conn :: connection(),
        |           Query :: iodata(),
        |           Params :: [term()],
        |           ColumnNames :: [binary()],
        |           Rows :: [[term()]],
        |           Reason :: server_reason().
        |  query(Conn, Query, Params) when is_list(Params) -&gt;
     3..|      gen_server:call(Conn, {query, Query, Params}).
        |  
        |  %% @doc Executes a prepared statement.
        |  %% @see prepare/2
        |  %% @see prepare/3
        |  -spec execute(Conn, StatementRef, Params) -&gt;
        |      ok | {ok, ColumnNames, Rows} | {error, Reason}
        |    when Conn :: connection(),
        |         StatementRef :: atom() | integer(),
        |         Params :: [term()],
        |         ColumnNames :: [binary()],
        |         Rows :: [[term()]],
        |         Reason :: server_reason() | not_prepared.
        |  execute(Conn, StatementRef, Params) -&gt;
   123..|      gen_server:call(Conn, {execute, StatementRef, Params}).
        |  
        |  %% @doc Creates a prepared statement from the passed query.
        |  %% @see prepare/3
        |  -spec prepare(Conn, Query) -&gt; {ok, StatementId} | {error, Reason}
        |    when Conn :: connection(),
        |         Query :: iodata(),
        |         StatementId :: integer(),
        |         Reason :: server_reason().
        |  prepare(Conn, Query) -&gt;
    58..|      gen_server:call(Conn, {prepare, Query}).
        |  
        |  %% @doc Creates a prepared statement from the passed query and associates it
        |  %% with the given name.
        |  %% @see prepare/2
        |  -spec prepare(Conn, Name, Query) -&gt; {ok, Name} | {error, Reason}
        |    when Conn :: connection(),
        |         Name :: atom(),
        |         Query :: iodata(),
        |         Reason :: server_reason().
        |  prepare(Conn, Name, Query) -&gt;
     3..|      gen_server:call(Conn, {prepare, Name, Query}).
        |  
        |  %% @doc Deallocates a prepared statement.
        |  -spec unprepare(Conn, StatementRef) -&gt; ok | {error, Reason}
        |    when Conn :: connection(),
        |         StatementRef :: atom() | integer(),
        |         Reason :: server_reason() | not_prepared.
        |  unprepare(Conn, StatementRef) -&gt;
    56..|      gen_server:call(Conn, {unprepare, StatementRef}).
        |  
        |  %% @doc Returns the number of warnings generated by the last query/2 or
        |  %% execute/3 calls.
        |  -spec warning_count(connection()) -&gt; integer().
        |  warning_count(Conn) -&gt;
     2..|      gen_server:call(Conn, warning_count).
        |  
        |  %% @doc Returns the number of inserted, updated and deleted rows of the last
        |  %% executed query or prepared statement.
        |  -spec affected_rows(connection()) -&gt; integer().
        |  affected_rows(Conn) -&gt;
     1..|      gen_server:call(Conn, affected_rows).
        |  
        |  %% @doc Returns true if auto-commit is enabled and false otherwise.
        |  -spec autocommit(connection()) -&gt; boolean().
        |  autocommit(Conn) -&gt;
     3..|      gen_server:call(Conn, autocommit).
        |  
        |  %% @doc Returns the last insert-id.
        |  -spec insert_id(connection()) -&gt; integer().
        |  insert_id(Conn) -&gt;
     1..|      gen_server:call(Conn, insert_id).
        |  
        |  %% @doc Returns true if the connection is in a transaction and false otherwise.
        |  %% This works regardless of whether the transaction has been started using
        |  %% transaction/2,3 or using a plain `mysql:query(Connection, "START
        |  %% TRANSACTION")'.
        |  %% @see transaction/2
        |  %% @see transaction/3
        |  -spec in_transaction(connection()) -&gt; boolean().
        |  in_transaction(Conn) -&gt;
     3..|      gen_server:call(Conn, in_transaction).
        |  
        |  %% @doc This function executes the functional object Fun as a transaction.
        |  %% @see transaction/3
        |  %% @see in_transaction/1
        |  -spec transaction(connection(), fun()) -&gt; {atomic, term()} | {aborted, term()}.
        |  transaction(Conn, Fun) -&gt;
     4..|      transaction(Conn, Fun, []).
        |  
        |  %% @doc This function executes the functional object Fun with arguments Args as
        |  %% a transaction. 
        |  %%
        |  %% The semantics are the same as for mnesia's transactions.
        |  %%
        |  %% The Fun must be a function and Args must be a list with the same length
        |  %% as the arity of Fun. 
        |  %%
        |  %% Current limitations:
        |  %%
        |  %% &lt;ul&gt;
        |  %%   &lt;li&gt;Transactions cannot be nested&lt;/li&gt;
        |  %%   &lt;li&gt;They are not automatically restarted when deadlocks are detected.&lt;/li&gt;
        |  %% &lt;/ul&gt;
        |  %%
        |  %% If an exception occurs within Fun, the exception is caught and `{aborted,
        |  %% Reason}' is returned. The value of `Reason' depends on the class of the
        |  %% exception.
        |  %%
        |  %% &lt;table&gt;
        |  %%   &lt;thead&gt;
        |  %%     &lt;tr&gt;&lt;th&gt;Class of exception&lt;/th&gt;&lt;th&gt;Return value&lt;/th&gt;&lt;/tr&gt;
        |  %%   &lt;/thead&gt;
        |  %%   &lt;tbody&gt;
        |  %%     &lt;tr&gt;
        |  %%       &lt;td&gt;`error' with reason `ErrorReason'&lt;/td&gt;
        |  %%       &lt;td&gt;`{aborted, {ErrorReason, Stack}}'&lt;/td&gt;
        |  %%     &lt;/tr&gt;
        |  %%     &lt;tr&gt;&lt;td&gt;`exit(Term)'&lt;/td&gt;&lt;td&gt;`{aborted, Term}'&lt;/td&gt;&lt;/tr&gt;
        |  %%     &lt;tr&gt;&lt;td&gt;`throw(Term)'&lt;/td&gt;&lt;td&gt;`{aborted, {throw, Term}}'&lt;/td&gt;&lt;/tr&gt;
        |  %%   &lt;/tbody&gt;
        |  %% &lt;/table&gt;
        |  %%
        |  %% TODO: Implement nested transactions
        |  %% TODO: Automatic restart on deadlocks
        |  %% @see in_transaction/1
        |  -spec transaction(connection(), fun(), list()) -&gt; {atomic, term()} |
        |                                                    {aborted, term()}.
        |  transaction(Conn, Fun, Args) when is_list(Args),
        |                                    is_function(Fun, length(Args)) -&gt;
        |      %% The guard makes sure that we can apply Fun to Args. Any error we catch
        |      %% in the try-catch are actual errors that occurred in Fun.
     4..|      ok = query(Conn, &lt;&lt;"BEGIN"&gt;&gt;),
     4..|      try apply(Fun, Args) of
        |          ResultOfFun -&gt;
        |              %% We must be able to rollback. Otherwise let's crash.
     1..|              ok = query(Conn, &lt;&lt;"COMMIT"&gt;&gt;),
     1..|              {atomic, ResultOfFun}
        |      catch
        |          Class:Reason -&gt;
        |              %% We must be able to rollback. Otherwise let's crash.
     3..|              ok = query(Conn, &lt;&lt;"ROLLBACK"&gt;&gt;),
        |              %% These forms for throw, error and exit mirror Mnesia's behaviour.
     3..|              Aborted = case Class of
     1..|                  throw -&gt; {throw, Reason};
     1..|                  error -&gt; {Reason, erlang:get_stacktrace()};
     1..|                  exit  -&gt; Reason
        |              end,
     3..|              {aborted, Aborted}
        |      end.
        |  
        |  %% --- Gen_server callbacks ---
        |  
        |  -include("records.hrl").
        |  -include("server_status.hrl").
        |  
        |  %% Gen_server state
        |  -record(state, {socket, timeout = infinity, affected_rows = 0, status = 0,
        |                  warning_count = 0, insert_id = 0, stmts = dict:new(),
        |                  query_cache_time, query_cache = empty}).
        |  
        |  %% @private
        |  init(Opts) -&gt;
        |      %% Connect
     4..|      Host     = proplists:get_value(host,     Opts, ?default_host),
     4..|      Port     = proplists:get_value(port,     Opts, ?default_port),
     4..|      User     = proplists:get_value(user,     Opts, ?default_user),
     4..|      Password = proplists:get_value(password, Opts, ?default_password),
     4..|      Database = proplists:get_value(database, Opts, undefined),
     4..|      Timeout  = proplists:get_value(timeout,  Opts, ?default_timeout),
     4..|      QueryCacheTime = proplists:get_value(query_cache_time, Opts,
        |                                           ?default_query_cache_time),
        |  
        |      %% Connect socket
     4..|      SockOpts = [{active, false}, binary, {packet, raw}],
     4..|      {ok, Socket} = gen_tcp:connect(Host, Port, SockOpts),
        |  
        |      %% Exchange handshake communication.
     4..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
     4..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
     4..|      Result = mysql_protocol:handshake(User, Password, Database, SendFun,
        |                                        RecvFun),
     4..|      case Result of
        |          #ok{} = OK -&gt;
     4..|              State = #state{socket = Socket, timeout = Timeout,
        |                             query_cache_time = QueryCacheTime},
     4..|              State1 = update_state(State, OK),
        |              %% Trap exit so that we can properly disconnect when we die.
     4..|              process_flag(trap_exit, true),
     4..|              {ok, State1};
        |          #error{} = E -&gt;
<font color=red>     0..|              {stop, error_to_reason(E)}</font>
        |      end.
        |  
        |  %% @private
        |  handle_call({query, Query}, _From, State) when is_binary(Query);
        |                                                 is_list(Query) -&gt;
   231..|      #state{socket = Socket, timeout = Timeout} = State,
   231..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
   231..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
   231..|      Rec = mysql_protocol:query(Query, SendFun, RecvFun),
   231..|      State1 = update_state(State, Rec),
   231..|      case Rec of
        |          #ok{} -&gt;
   150..|              {reply, ok, State1};
        |          #error{} = E -&gt;
     1..|              {reply, {error, error_to_reason(E)}, State1};
        |          #resultset{cols = ColDefs, rows = Rows} -&gt;
    80..|              Names = [Def#col.name || Def &lt;- ColDefs],
    80..|              {reply, {ok, Names, Rows}, State1}
        |      end;
        |  handle_call({query, Query, Params}, _From, State) when is_list(Params) -&gt;
        |      %% Parametrized query = anonymous prepared statement
     3..|      QueryBin = iolist_to_binary(Query),
     3..|      #state{socket = Socket, timeout = Timeout} = State,
     3..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
     3..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
     3..|      Cache = State#state.query_cache,
     3..|      {StmtResult, Cache1} = case mysql_cache:lookup(QueryBin, Cache) of
        |          {found, FoundStmt, NewCache} -&gt;
        |              %% Found
     1..|              {{ok, FoundStmt}, NewCache};
        |          not_found -&gt;
        |              %% Prepare
     2..|              Rec = mysql_protocol:prepare(Query, SendFun, RecvFun),
        |              %State1 = update_state(State, Rec),
     2..|              case Rec of
        |                  #error{} = E -&gt;
<font color=red>     0..|                      {{error, error_to_reason(E)}, Cache};</font>
        |                  #prepared{} = Stmt -&gt;
        |                      %% If the first entry in the cache, start the timer.
     2..|                      Cache == empty andalso begin
     2..|                          When = State#state.query_cache_time * 2,
     2..|                          erlang:send_after(When, self(), query_cache)
        |                      end,
     2..|                      {{ok, Stmt}, mysql_cache:store(QueryBin, Stmt, Cache)}
        |              end
        |      end,
     3..|      case StmtResult of
        |          {ok, StmtRec} -&gt;
     3..|              State1 = State#state{query_cache = Cache1},
     3..|              execute_stmt(StmtRec, Params, State1);
        |          PrepareError -&gt;
<font color=red>     0..|              {reply, PrepareError, State}</font>
        |      end;
        |  handle_call({execute, Stmt, Args}, _From, State) when is_atom(Stmt);
        |                                                        is_integer(Stmt) -&gt;
   123..|      case dict:find(Stmt, State#state.stmts) of
        |          {ok, StmtRec} -&gt;
   122..|              execute_stmt(StmtRec, Args, State);
        |          error -&gt;
     1..|              {reply, {error, not_prepared}, State}
        |      end;
        |  handle_call({prepare, Query}, _From, State) -&gt;
    58..|      #state{socket = Socket, timeout = Timeout} = State,
    58..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
    58..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
    58..|      Rec = mysql_protocol:prepare(Query, SendFun, RecvFun),
    58..|      State1 = update_state(State, Rec),
    58..|      case Rec of
        |          #error{} = E -&gt;
     1..|              {reply, {error, error_to_reason(E)}, State1};
        |          #prepared{statement_id = Id} = Stmt -&gt;
    57..|              Stmts1 = dict:store(Id, Stmt, State1#state.stmts),
    57..|              State2 = State#state{stmts = Stmts1},
    57..|              {reply, {ok, Id}, State2}
        |      end;
        |  handle_call({prepare, Name, Query}, _From, State) when is_atom(Name) -&gt;
     3..|      #state{socket = Socket, timeout = Timeout} = State,
     3..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
     3..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
        |      %% First unprepare if there is an old statement with this name.
     3..|      State1 = case dict:find(Name, State#state.stmts) of
        |          {ok, OldStmt} -&gt;
     1..|              mysql_protocol:unprepare(OldStmt, SendFun, RecvFun),
     1..|              State#state{stmts = dict:erase(Name, State#state.stmts)};
        |          error -&gt;
     2..|              State
        |      end,
     3..|      Rec = mysql_protocol:prepare(Query, SendFun, RecvFun),
     3..|      State2 = update_state(State1, Rec),
     3..|      case Rec of
        |          #error{} = E -&gt;
     1..|              {reply, {error, error_to_reason(E)}, State2};
        |          #prepared{} = Stmt -&gt;
     2..|              Stmts1 = dict:store(Name, Stmt, State2#state.stmts),
     2..|              State3 = State2#state{stmts = Stmts1},
     2..|              {reply, {ok, Name}, State3}
        |      end;
        |  handle_call({unprepare, Stmt}, _From, State) when is_atom(Stmt);
        |                                                    is_integer(Stmt) -&gt;
    56..|      case dict:find(Stmt, State#state.stmts) of
        |          {ok, StmtRec} -&gt;
    54..|              #state{socket = Socket, timeout = Timeout} = State,
    54..|              SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
    54..|              RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
    54..|              mysql_protocol:unprepare(StmtRec, SendFun, RecvFun),
    54..|              Stmts1 = dict:erase(Stmt, State#state.stmts),
    54..|              {reply, ok, State#state{stmts = Stmts1}};
        |          error -&gt;
     2..|              {reply, {error, not_prepared}, State}
        |      end;
        |  handle_call(warning_count, _From, State) -&gt;
     2..|      {reply, State#state.warning_count, State};
        |  handle_call(insert_id, _From, State) -&gt;
     1..|      {reply, State#state.insert_id, State};
        |  handle_call(affected_rows, _From, State) -&gt;
     1..|      {reply, State#state.affected_rows, State};
        |  handle_call(autocommit, _From, State) -&gt;
     3..|      {reply, State#state.status band ?SERVER_STATUS_AUTOCOMMIT /= 0, State};
        |  handle_call(in_transaction, _From, State) -&gt;
     3..|      {reply, State#state.status band ?SERVER_STATUS_IN_TRANS /= 0, State}.
        |  
        |  %% @private
        |  handle_cast(_Msg, State) -&gt;
     1..|      {noreply, State}.
        |  
        |  %% @private
        |  handle_info(query_cache, State = #state{query_cache = Cache,
        |                                          query_cache_time = CacheTime}) -&gt;
        |      %% Evict expired queries/statements in the cache used by query/3.
     1..|      {Evicted, Cache1} = mysql_cache:evict_older_than(Cache, CacheTime),
        |      %% Unprepare the evicted statements
     1..|      #state{socket = Socket, timeout = Timeout} = State,
     1..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
     1..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
     1..|      lists:foreach(fun ({_Query, Stmt}) -&gt;
     1..|                        mysql_protocol:unprepare(Stmt, SendFun, RecvFun)
        |                    end,
        |                    Evicted),
        |      %% If nonempty, schedule eviction again.
     1..|      mysql_cache:size(Cache1) &gt; 0 andalso
<font color=red>     0..|          erlang:send_after(CacheTime, self(), query_cache),</font>
     1..|      {noreply, State#state{query_cache = Cache1}};
        |  handle_info(_Info, State) -&gt;
     1..|      {noreply, State}.
        |  
        |  %% @private
        |  terminate(Reason, State) when Reason == normal; Reason == shutdown -&gt;
        |      %% Send the goodbye message for politeness.
     4..|      #state{socket = Socket, timeout = Timeout} = State,
     4..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
     4..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
     4..|      mysql_protocol:quit(SendFun, RecvFun);
        |  terminate(_Reason, _State) -&gt;
     1..|      ok.
        |  
        |  %% @private
        |  code_change(_OldVsn, State = #state{}, _Extra) -&gt;
     1..|      {ok, State};
        |  code_change(_OldVsn, _State, _Extra) -&gt;
     1..|      {error, incompatible_state}.
        |  
        |  %% --- Helpers ---
        |  
        |  %% @doc Returns a tuple on the the same form as handle_call/3.
        |  execute_stmt(StmtRec, Args, State) -&gt;
   125..|      #state{socket = Socket, timeout = Timeout} = State,
   125..|      SendFun = fun (Data) -&gt; gen_tcp:send(Socket, Data) end,
   125..|      RecvFun = fun (Size) -&gt; gen_tcp:recv(Socket, Size, Timeout) end,
   125..|      Rec = mysql_protocol:execute(StmtRec, Args, SendFun, RecvFun),
   125..|      State1 = update_state(State, Rec),
   125..|      case Rec of
        |          #ok{} -&gt;
    48..|              {reply, ok, State1};
        |          #error{} = E -&gt;
<font color=red>     0..|              {reply, {error, error_to_reason(E)}, State1};</font>
        |          #resultset{cols = ColDefs, rows = Rows} -&gt;
    77..|              Names = [Def#col.name || Def &lt;- ColDefs],
    77..|              {reply, {ok, Names, Rows}, State1}
        |      end.
        |  
        |  %% @doc Produces a tuple to return as an error reason.
        |  -spec error_to_reason(#error{}) -&gt; server_reason().
        |  error_to_reason(#error{code = Code, state = State, msg = Msg}) -&gt;
     3..|      {Code, State, Msg}.
        |  
        |  %% @doc Updates a state with information from a response.
        |  -spec update_state(#state{}, #ok{} | #eof{} | any()) -&gt; #state{}.
        |  update_state(State, #ok{status = S, affected_rows = R,
        |                          insert_id = Id, warning_count = W}) -&gt;
   202..|      State#state{status = S, affected_rows = R, insert_id = Id,
        |                  warning_count = W};
        |  %update_state(State, #eof{status = S, warning_count = W}) -&gt;
        |  %    State#state{status = S, warning_count = W, affected_rows = 0};
        |  update_state(State, #prepared{warning_count = W}) -&gt;
    59..|      State#state{warning_count = W};
        |  update_state(State, _Other) -&gt;
        |      %% This includes errors, resultsets, etc.
        |      %% Reset warnings, etc. (Note: We don't reset status and insert_id.)
   160..|      State#state{warning_count = 0, affected_rows = 0}.
</pre>
</body>
</html>
