<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>.eunit/mysql_protocol.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /Users/viktor/data/mysql-otp/.eunit/mysql_protocol.erl by COVER 2014-12-10 at 23:06:44

****************************************************************************

        |  %% MySQL/OTP – MySQL client library for Erlang/OTP
        |  %% Copyright (C) 2014 Viktor Söderqvist
        |  %%
        |  %% This file is part of MySQL/OTP.
        |  %%
        |  %% MySQL/OTP is free software: you can redistribute it and/or modify it under
        |  %% the terms of the GNU Lesser General Public License as published by the Free
        |  %% Software Foundation, either version 3 of the License, or (at your option)
        |  %% any later version.
        |  %%
        |  %% This program is distributed in the hope that it will be useful, but WITHOUT
        |  %% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
        |  %% FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
        |  %% more details.
        |  %%
        |  %% You should have received a copy of the GNU Lesser General Public License
        |  %% along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
        |  
        |  %% @doc This module implements parts of the MySQL client/server protocol.
        |  %%
        |  %% The protocol is described in the document "MySQL Internals" which can be
        |  %% found under "MySQL Documentation: Expert Guides" on http://dev.mysql.com/.
        |  %%
        |  %% TCP communication is not handled in this module. Most of the public functions
        |  %% take funs for data communitaction as parameters.
        |  %% @private
        |  -module(mysql_protocol).
        |  
        |  -export([handshake/5, quit/2,
        |           query/3,
        |           prepare/3, unprepare/3, execute/4]).
        |  
        |  -export_type([sendfun/0, recvfun/0]).
        |  
        |  -type sendfun() :: fun((binary()) -&gt; ok).
        |  -type recvfun() :: fun((integer()) -&gt; {ok, binary()}).
        |  
        |  %% How much data do we want to send at most?
        |  -define(MAX_BYTES_PER_PACKET, 50000000).
        |  
        |  -include("records.hrl").
        |  -include("protocol.hrl").
        |  
        |  %% Macros for pattern matching on packets.
        |  -define(ok_pattern, &lt;&lt;?OK, _/binary&gt;&gt;).
        |  -define(error_pattern, &lt;&lt;?ERROR, _/binary&gt;&gt;).
        |  -define(eof_pattern, &lt;&lt;?EOF, _:4/binary&gt;&gt;).
        |  
        |  %% @doc Performs a handshake using the supplied functions for communication.
        |  %% Returns an ok or an error record. Raises errors when various unimplemented
        |  %% features are requested.
        |  -spec handshake(iodata(), iodata(), iodata() | undefined, sendfun(),
        |                  recvfun()) -&gt; #ok{} | #error{}.
        |  handshake(Username, Password, Database, SendFun, RecvFun) -&gt;
     4..|      SeqNum0 = 0,
     4..|      {ok, HandshakePacket, SeqNum1} = recv_packet(RecvFun, SeqNum0),
     4..|      Handshake = parse_handshake(HandshakePacket),
     4..|      Response = build_handshake_response(Handshake, Username, Password,
        |                                          Database),
     4..|      {ok, SeqNum2} = send_packet(SendFun, Response, SeqNum1),
     4..|      {ok, ConfirmPacket, _SeqNum3} = recv_packet(RecvFun, SeqNum2),
     4..|      parse_handshake_confirm(ConfirmPacket).
        |  
        |  quit(SendFun, RecvFun) -&gt;
     4..|      {ok, SeqNum1} = send_packet(SendFun, &lt;&lt;?COM_QUIT&gt;&gt;, 0),
     4..|      case recv_packet(RecvFun, SeqNum1) of
     4..|          {error, closed} -&gt; ok;
<font color=red>     0..|          {ok, ?ok_pattern, _SeqNum2} -&gt; ok</font>
        |      end.
        |  
        |  -spec query(Query :: iodata(), sendfun(), recvfun()) -&gt;
        |      #ok{} | #error{} | #resultset{}.
        |  query(Query, SendFun, RecvFun) -&gt;
   233..|      Req = &lt;&lt;?COM_QUERY, (iolist_to_binary(Query))/binary&gt;&gt;,
   233..|      SeqNum0 = 0,
   233..|      {ok, SeqNum1} = send_packet(SendFun, Req, SeqNum0),
   233..|      {ok, Resp, SeqNum2} = recv_packet(RecvFun, SeqNum1),
   233..|      case Resp of
        |          ?ok_pattern -&gt;
   150..|              parse_ok_packet(Resp);
        |          ?error_pattern -&gt;
     1..|              parse_error_packet(Resp);
        |          _ResultSet -&gt;
        |              %% The first packet in a resultset is only the column count.
    82..|              {ColumnCount, &lt;&lt;&gt;&gt;} = lenenc_int(Resp),
    82..|              case fetch_resultset(RecvFun, ColumnCount, SeqNum2) of
        |                  #error{} = E -&gt;
     1..|                      E;
        |                  #resultset{cols = ColDefs, rows = Rows} = R -&gt;
        |                      %% Parse the rows according to the 'text protocol'
        |                      %% representation.
    81..|                      Rows1 = [decode_text_row(ColumnCount, ColDefs, Row)
    81..|                               || Row &lt;- Rows],
    81..|                      R#resultset{rows = Rows1}
        |              end
        |      end.
        |  
        |  %% @doc Prepares a statement.
        |  -spec prepare(iodata(), sendfun(), recvfun()) -&gt; #error{} | #prepared{}.
        |  prepare(Query, SendFun, RecvFun) -&gt;
    64..|      Req = &lt;&lt;?COM_STMT_PREPARE, (iolist_to_binary(Query))/binary&gt;&gt;,
    64..|      {ok, SeqNum1} = send_packet(SendFun, Req, 0),
    64..|      {ok, Resp, SeqNum2} = recv_packet(RecvFun, SeqNum1),
    64..|      case Resp of
        |          ?error_pattern -&gt;
     2..|              parse_error_packet(Resp);
        |          &lt;&lt;?OK,
        |            StmtId:32/little,
        |            NumColumns:16/little,
        |            NumParams:16/little,
        |            0, %% reserved_1 -- [00] filler
        |            WarningCount:16/little&gt;&gt; -&gt;
        |              %% This was the first packet.
        |              %% Now: Parameter Definition Block. The parameter definitions don't
        |              %% contain any useful data at all. They are always TYPE_VAR_STRING
        |              %% with charset 'binary' so we have to select a type ourselves for
        |              %% the parameters we have in execute/4.
    62..|              {_ParamDefs, SeqNum3} =
        |                  fetch_column_definitions_if_any(NumParams, RecvFun, SeqNum2),
        |              %% Column Definition Block. We get column definitions in execute
        |              %% too, so we don't need them here. We *could* store them to be able
        |              %% to provide the user with some info about a prepared statement.
    62..|              {_ColDefs, _SeqNum4} =
        |                  fetch_column_definitions_if_any(NumColumns, RecvFun, SeqNum3),
    62..|              #prepared{statement_id = StmtId,
        |                        param_count = NumParams,
        |                        warning_count = WarningCount}
        |      end.
        |  
        |  %% @doc Deallocates a prepared statement.
        |  -spec unprepare(#prepared{}, sendfun(), recvfun()) -&gt; ok.
        |  unprepare(#prepared{statement_id = Id}, SendFun, _RecvFun) -&gt;
    56..|      {ok, _SeqNum} = send_packet(SendFun, &lt;&lt;?COM_STMT_CLOSE, Id:32/little&gt;&gt;, 0),
    56..|      ok.
        |  
        |  %% @doc Executes a prepared statement.
        |  -spec execute(#prepared{}, [term()], sendfun(), recvfun()) -&gt; #resultset{}.
        |  execute(#prepared{statement_id = Id, param_count = ParamCount}, ParamValues,
        |          SendFun, RecvFun) when ParamCount == length(ParamValues) -&gt;
        |      %% Flags Constant Name
        |      %% 0x00 CURSOR_TYPE_NO_CURSOR
        |      %% 0x01 CURSOR_TYPE_READ_ONLY
        |      %% 0x02 CURSOR_TYPE_FOR_UPDATE
        |      %% 0x04 CURSOR_TYPE_SCROLLABLE
   125..|      Flags = 0,
   125..|      Req0 = &lt;&lt;?COM_STMT_EXECUTE, Id:32/little, Flags, 1:32/little&gt;&gt;,
   125..|      Req = case ParamCount of
        |          0 -&gt;
    73..|              Req0;
        |          _ -&gt;
        |              %% We can't use the parameter types returned by the prepare call.
        |              %% They are all reported as ?TYPE_VAR_STRING with character
        |              %% set 'binary'.
    52..|              NullBitMap = build_null_bitmap(ParamValues),
        |              %% What does it mean to *not* bind new params? To use the same
        |              %% params as last time? Right now we always bind params each time.
    52..|              NewParamsBoundFlag = 1,
    52..|              Req1 = &lt;&lt;Req0/binary, NullBitMap/binary, NewParamsBoundFlag&gt;&gt;,
        |              %% For each value, first append type and signedness (16#80 signed or
        |              %% 00 unsigned) for all values and then the binary encoded values.
    52..|              EncodedParams = lists:map(fun encode_param/1, ParamValues),
    52..|              {TypesAndSigns, EncValues} = lists:unzip(EncodedParams),
    52..|              iolist_to_binary([Req1, TypesAndSigns, EncValues])
        |      end,
   125..|      {ok, SeqNum1} = send_packet(SendFun, Req, 0),
   125..|      {ok, Resp, SeqNum2} = recv_packet(RecvFun, SeqNum1),
   125..|      case Resp of
        |          ?ok_pattern -&gt;
    48..|              parse_ok_packet(Resp);
        |          ?error_pattern -&gt;
<font color=red>     0..|              parse_error_packet(Resp);</font>
        |          _ResultPacket -&gt;
        |              %% The first packet in a resultset is only the column count.
    77..|              {ColumnCount, &lt;&lt;&gt;&gt;} = lenenc_int(Resp),
    77..|              case fetch_resultset(RecvFun, ColumnCount, SeqNum2) of
        |                  #error{} = E -&gt;
        |                      %% TODO: Find a way to get here and write a testcase.
        |                      %% This can happen for the text protocol but maybe not for
        |                      %% the binary protocol.
<font color=red>     0..|                      E;</font>
        |                  #resultset{cols = ColDefs, rows = Rows} = R -&gt;
        |                      %% Parse the rows according to the 'binary protocol'
        |                      %% representation.
    77..|                      Rows1 = [decode_binary_row(ColumnCount, ColDefs, Row)
    77..|                               || Row &lt;- Rows],
    77..|                      R#resultset{rows = Rows1}
        |              end
        |      end.
        |  
        |  %% --- internal ---
        |  
        |  %% @doc Parses a handshake. This is the first thing that comes from the server
        |  %% when connecting. If an unsupported version or variant of the protocol is used
        |  %% an error is raised.
        |  -spec parse_handshake(binary()) -&gt; #handshake{}.
        |  parse_handshake(&lt;&lt;10, Rest/binary&gt;&gt;) -&gt;
        |      %% Protocol version 10.
     4..|      {ServerVersion, Rest1} = nulterm_str(Rest),
        |      &lt;&lt;ConnectionId:32/little,
        |        AuthPluginDataPart1:8/binary-unit:8,
        |        0, %% "filler" -- everything below is optional
        |        CapabilitiesLower:16/little,
        |        CharacterSet:8,
        |        StatusFlags:16/little,
        |        CapabilitiesUpper:16/little,
        |        AuthPluginDataLength:8,     %% if cabab &amp; CLIENT_PLUGIN_AUTH, otherwise 0
        |        _Reserved:10/binary-unit:8, %% 10 unused (reserved) bytes
     4..|        Rest3/binary&gt;&gt; = Rest1,
     4..|      Capabilities = CapabilitiesLower + 16#10000 * CapabilitiesUpper,
     4..|      Len = case AuthPluginDataLength of
<font color=red>     0..|          0 -&gt; 13;   %% Server has not CLIENT_PLUGIN_AUTH</font>
     4..|          K -&gt; K - 8 %% Part 2 length = Total length minus the 8 bytes in part 1.
        |      end,
     4..|      &lt;&lt;AuthPluginDataPart2:Len/binary-unit:8, AuthPluginName/binary&gt;&gt; = Rest3,
     4..|      AuthPluginData = &lt;&lt;AuthPluginDataPart1/binary, AuthPluginDataPart2/binary&gt;&gt;,
        |      %% "Due to Bug#59453 the auth-plugin-name is missing the terminating
        |      %% NUL-char in versions prior to 5.5.10 and 5.6.2."
        |      %% Strip the final NUL byte if any.
     4..|      NameLen = size(AuthPluginName) - 1,
     4..|      AuthPluginName1 = case AuthPluginName of
     4..|          &lt;&lt;NameNoNul:NameLen/binary-unit:8, 0&gt;&gt; -&gt; NameNoNul;
<font color=red>     0..|          _ -&gt; AuthPluginName</font>
        |      end,
     4..|      #handshake{server_version = ServerVersion,
        |                connection_id = ConnectionId,
        |                capabilities = Capabilities,
        |                character_set = CharacterSet,
        |                status = StatusFlags,
        |                auth_plugin_data = AuthPluginData,
        |                auth_plugin_name = AuthPluginName1};
        |  parse_handshake(&lt;&lt;Protocol:8, _/binary&gt;&gt;) when Protocol /= 10 -&gt;
<font color=red>     0..|      error(unknown_protocol).</font>
        |  
        |  %% @doc The response sent by the client to the server after receiving the
        |  %% initial handshake from the server
        |  -spec build_handshake_response(#handshake{}, iodata(), iodata(),
        |                                 iodata() | undefined) -&gt; binary().
        |  build_handshake_response(Handshake, Username, Password, Database) -&gt;
        |      %% We require these capabilities. Make sure the server handles them.
     4..|      CapabilityFlags0 = ?CLIENT_PROTOCOL_41 bor
        |                         ?CLIENT_TRANSACTIONS bor
        |                         ?CLIENT_SECURE_CONNECTION,
     4..|      CapabilityFlags = case Database of
     3..|          undefined -&gt; CapabilityFlags0;
     1..|          _         -&gt; CapabilityFlags0 bor ?CLIENT_CONNECT_WITH_DB
        |      end,
     4..|      Handshake#handshake.capabilities band CapabilityFlags == CapabilityFlags
<font color=red>     0..|          orelse error(old_server_version),</font>
     4..|      Hash = case Handshake#handshake.auth_plugin_name of
        |          &lt;&lt;&gt;&gt; -&gt;
        |              %% Server doesn't know auth plugins
<font color=red>     0..|              hash_password(Password, Handshake#handshake.auth_plugin_data);</font>
        |          &lt;&lt;"mysql_native_password"&gt;&gt; -&gt;
     4..|              hash_password(Password, Handshake#handshake.auth_plugin_data);
        |          UnknownAuthMethod -&gt;
<font color=red>     0..|              error({auth_method, UnknownAuthMethod})</font>
        |      end,
     4..|      HashLength = size(Hash),
     4..|      CharacterSet = ?UTF8,
     4..|      UsernameUtf8 = unicode:characters_to_binary(Username),
     4..|      DbBin = case Database of
     3..|          undefined -&gt; &lt;&lt;&gt;&gt;;
     1..|          _         -&gt; &lt;&lt;(iolist_to_binary(Database))/binary, 0&gt;&gt;
        |      end,
     4..|      &lt;&lt;CapabilityFlags:32/little,
        |        ?MAX_BYTES_PER_PACKET:32/little,
        |        CharacterSet:8,
        |        0:23/unit:8, %% reserverd
        |        UsernameUtf8/binary,
        |        0, %% NUL-terminator for the username
        |        HashLength,
        |        Hash/binary,
        |        DbBin/binary&gt;&gt;.
        |  
        |  %% @doc Handles the second packet from the server, when we have replied to the
        |  %% initial handshake. Returns an error if the server returns an error. Raises
        |  %% an error if unimplemented features are required.
        |  -spec parse_handshake_confirm(binary()) -&gt; #ok{} | #error{}.
        |  parse_handshake_confirm(Packet) -&gt;
     4..|      case Packet of
        |          ?ok_pattern -&gt;
        |              %% Connection complete.
     4..|              parse_ok_packet(Packet);
        |          ?error_pattern -&gt;
        |              %% "Insufficient Client Capabilities"
<font color=red>     0..|              parse_error_packet(Packet);</font>
        |          &lt;&lt;?EOF&gt;&gt; -&gt;
        |              %% "Old Authentication Method Switch Request Packet consisting of a
        |              %% single 0xfe byte. It is sent by server to request client to
        |              %% switch to Old Password Authentication if CLIENT_PLUGIN_AUTH
        |              %% capability is not supported (by either the client or the server)"
<font color=red>     0..|              error(old_auth);</font>
        |          &lt;&lt;?EOF, _/binary&gt;&gt; -&gt;
        |              %% "Authentication Method Switch Request Packet. If both server and
        |              %% client support CLIENT_PLUGIN_AUTH capability, server can send
        |              %% this packet to ask client to use another authentication method."
<font color=red>     0..|              error(auth_method_switch)</font>
        |      end.
        |  
        |  %% -- both text and binary protocol --
        |  
        |  %% @doc Fetches packets for a result set. The column definitions are parsed but
        |  %% the rows are unparsed binary packages. This function is used for both the
        |  %% text protocol and the binary protocol. This affects the way the rows need to
        |  %% be parsed.
        |  -spec fetch_resultset(recvfun(), integer(), integer()) -&gt;
        |      #resultset{} | #error{}.
        |  fetch_resultset(RecvFun, FieldCount, SeqNum) -&gt;
   159..|      {ok, ColDefs, SeqNum1} = fetch_column_definitions(RecvFun, SeqNum,
        |                                                        FieldCount, []),
   159..|      {ok, DelimiterPacket, SeqNum2} = recv_packet(RecvFun, SeqNum1),
   159..|      #eof{} = parse_eof_packet(DelimiterPacket),
   159..|      case fetch_resultset_rows(RecvFun, SeqNum2, []) of
        |          {ok, Rows, _SeqNum3} -&gt;
   158..|              ColDefs1 = lists:map(fun parse_column_definition/1, ColDefs),
   158..|              #resultset{cols = ColDefs1, rows = Rows};
        |          #error{} = E -&gt;
     1..|              E
        |      end.
        |  
        |  %% @doc Receives NumLeft column definition packets. They are not parsed.
        |  %% @see parse_column_definition/1
        |  -spec fetch_column_definitions(recvfun(), SeqNum :: integer(),
        |                                 NumLeft :: integer(), Acc :: [binary()]) -&gt;
        |      {ok, ColDefPackets :: [binary()], NextSeqNum :: integer()}.
        |  fetch_column_definitions(RecvFun, SeqNum, NumLeft, Acc) when NumLeft &gt; 0 -&gt;
   269..|      {ok, Packet, SeqNum1} = recv_packet(RecvFun, SeqNum),
   269..|      fetch_column_definitions(RecvFun, SeqNum1, NumLeft - 1, [Packet | Acc]);
        |  fetch_column_definitions(_RecvFun, SeqNum, 0, Acc) -&gt;
   228..|      {ok, lists:reverse(Acc), SeqNum}.
        |  
        |  %% @doc Fetches rows in a result set. There is a packet per row. The row packets
        |  %% are not decoded. This function can be used for both the binary and the text
        |  %% protocol result sets.
        |  -spec fetch_resultset_rows(recvfun(), SeqNum :: integer(), Acc) -&gt;
        |      {ok, Rows, integer()} | #error{}
        |      when Acc :: [binary()],
        |           Rows :: [binary()].
        |  fetch_resultset_rows(RecvFun, SeqNum, Acc) -&gt;
   314..|      {ok, Packet, SeqNum1} = recv_packet(RecvFun, SeqNum),
   314..|      case Packet of
        |          ?error_pattern -&gt;
     1..|              parse_error_packet(Packet);
        |          ?eof_pattern -&gt;
   158..|              {ok, lists:reverse(Acc), SeqNum1};
        |          Row -&gt;
   155..|              fetch_resultset_rows(RecvFun, SeqNum1, [Row | Acc])
        |      end.
        |  
        |  %% Parses a packet containing a column definition (part of a result set)
        |  parse_column_definition(Data) -&gt;
   175..|      {&lt;&lt;"def"&gt;&gt;, Rest1} = lenenc_str(Data),   %% catalog (always "def")
   175..|      {_Schema, Rest2} = lenenc_str(Rest1),    %% schema-name 
   175..|      {_Table, Rest3} = lenenc_str(Rest2),     %% virtual table-name 
   175..|      {_OrgTable, Rest4} = lenenc_str(Rest3),  %% physical table-name 
   175..|      {Name, Rest5} = lenenc_str(Rest4),       %% virtual column name
   175..|      {_OrgName, Rest6} = lenenc_str(Rest5),   %% physical column name
   175..|      {16#0c, Rest7} = lenenc_int(Rest6),      %% length of the following fields
        |                                               %% (always 0x0c)
        |      &lt;&lt;Charset:16/little,        %% column character set
        |        Length:32/little,         %% maximum length of the field
        |        Type:8,                   %% type of the column as defined in Column Type
        |        Flags:16/little,          %% flags
        |        Decimals:8,               %% max shown decimal digits:
        |        0,  %% "filler"           %%   - 0x00 for integers and static strings
        |        0,                        %%   - 0x1f for dynamic strings, double, float
   175..|        Rest8/binary&gt;&gt; = Rest7,   %%   - 0x00 to 0x51 for decimals
        |      %% Here, if command was COM_FIELD_LIST {
        |      %%   default values: lenenc_str
        |      %% }
   175..|      &lt;&lt;&gt;&gt; = Rest8,
   175..|      #col{name = Name, type = Type, charset = Charset, length = Length,
        |           decimals = Decimals, flags = Flags}.
        |  
        |  %% -- text protocol --
        |  
        |  -spec decode_text_row(NumColumns :: integer(),
        |                        ColumnDefinitions :: [#col{}],
        |                        Data :: binary()) -&gt; [term()].
        |  decode_text_row(_NumColumns, ColumnDefs, Data) -&gt;
    81..|      decode_text_row_acc(ColumnDefs, Data, []).
        |  
        |  %% parses Data using ColDefs and builds the values Acc.
        |  decode_text_row_acc([ColDef | ColDefs], Data, Acc) -&gt;
    90..|      case Data of
        |          &lt;&lt;16#fb, Rest/binary&gt;&gt; -&gt;
        |              %% NULL
     1..|              decode_text_row_acc(ColDefs, Rest, [null | Acc]);
        |          _ -&gt;
        |              %% Every thing except NULL
    89..|              {Text, Rest} = lenenc_str(Data),
    89..|              Term = decode_text(ColDef, Text),
    89..|              decode_text_row_acc(ColDefs, Rest, [Term | Acc])
        |      end;
        |  decode_text_row_acc([], &lt;&lt;&gt;&gt;, Acc) -&gt;
    81..|      lists:reverse(Acc).
        |  
        |  %% @doc When receiving data in the text protocol, we get everything as binaries
        |  %% (except NULL). This function is used to parse these strings values.
        |  decode_text(_, null) -&gt;
        |      %% NULL is the only value not represented as a binary.
     1..|      null;
        |  decode_text(#col{type = T}, Text)
        |    when T == ?TYPE_TINY; T == ?TYPE_SHORT; T == ?TYPE_LONG; T == ?TYPE_LONGLONG;
        |         T == ?TYPE_INT24; T == ?TYPE_YEAR -&gt;
    24..|      binary_to_integer(Text);
        |  decode_text(#col{type = T}, Text)
        |    when T == ?TYPE_STRING; T == ?TYPE_VARCHAR; T == ?TYPE_VAR_STRING;
        |         T == ?TYPE_ENUM; T == ?TYPE_SET; T == ?TYPE_LONG_BLOB;
        |         T == ?TYPE_MEDIUM_BLOB; T == ?TYPE_BLOB; T == ?TYPE_TINY_BLOB;
        |         T == ?TYPE_GEOMETRY -&gt;
        |      %% As of MySQL 5.6.21 we receive SET and ENUM values as STRING, i.e. we
        |      %% cannot convert them to atom() or sets:set(), etc.
    15..|      Text;
        |  decode_text(#col{type = ?TYPE_BIT, length = Length}, Text) -&gt;
        |      %% Convert to &lt;&lt;_:Length/bitstring&gt;&gt;
     5..|      decode_bitstring(Text, Length);
        |  decode_text(#col{type = T, decimals = S, length = L}, Text)
        |    when T == ?TYPE_DECIMAL; T == ?TYPE_NEWDECIMAL -&gt;
        |      %% Length is the max number of symbols incl. dot and minus sign, e.g. the
        |      %% number of digits plus 2.
    19..|      decode_decimal(Text, L - 2, S);
        |  decode_text(#col{type = ?TYPE_DATE},
        |              &lt;&lt;Y:4/binary, "-", M:2/binary, "-", D:2/binary&gt;&gt;) -&gt;
     2..|      {binary_to_integer(Y), binary_to_integer(M), binary_to_integer(D)};
        |  decode_text(#col{type = ?TYPE_TIME}, Text) -&gt;
    20..|      {match, [Sign, Hbin, Mbin, Sbin, Frac]} =
        |          re:run(Text,
        |                 &lt;&lt;"^(-?)(\\d+):(\\d+):(\\d+)(\\.?\\d*)$"&gt;&gt;,
        |                 [{capture, all_but_first, binary}]),
    20..|      H = binary_to_integer(Hbin),
    20..|      M = binary_to_integer(Mbin),
    20..|      S = binary_to_integer(Sbin),
    20..|      IsNeg = Sign == &lt;&lt;"-"&gt;&gt;,
    20..|      Fraction = case Frac of
    16..|          &lt;&lt;&gt;&gt; -&gt; 0;
     2..|          _ when not IsNeg -&gt; binary_to_float(&lt;&lt;"0", Frac/binary&gt;&gt;);
     2..|          _ when IsNeg -&gt; 1 - binary_to_float(&lt;&lt;"0", Frac/binary&gt;&gt;)
        |      end,
    20..|      Sec1 = H * 3600 + M * 60 + S,
    20..|      Sec2 = if IsNeg -&gt; -Sec1; true -&gt; Sec1 end,
    20..|      Sec3 = if IsNeg and (Fraction /= 0) -&gt; Sec2 - 1;
    18..|                true                      -&gt; Sec2
        |             end,
    20..|      {Days, {Hours, Minutes, Seconds}} = calendar:seconds_to_daystime(Sec3),
    20..|      {Days, {Hours, Minutes, Seconds + Fraction}};
        |  decode_text(#col{type = T},
        |              &lt;&lt;Y:4/binary, "-", M:2/binary, "-", D:2/binary, " ",
        |                H:2/binary, ":", Mi:2/binary, ":", S:2/binary&gt;&gt;)
        |    when T == ?TYPE_TIMESTAMP; T == ?TYPE_DATETIME -&gt;
        |      %% Without fractions.
     3..|      {{binary_to_integer(Y), binary_to_integer(M), binary_to_integer(D)},
        |       {binary_to_integer(H), binary_to_integer(Mi), binary_to_integer(S)}};
        |  decode_text(#col{type = T},
        |              &lt;&lt;Y:4/binary, "-", M:2/binary, "-", D:2/binary, " ",
        |                H:2/binary, ":", Mi:2/binary, ":", FloatS/binary&gt;&gt;)
        |    when T == ?TYPE_TIMESTAMP; T == ?TYPE_DATETIME -&gt;
        |      %% With fractions.
     2..|      {{binary_to_integer(Y), binary_to_integer(M), binary_to_integer(D)},
        |       {binary_to_integer(H), binary_to_integer(Mi), binary_to_float(FloatS)}};
        |  decode_text(#col{type = T}, Text) when T == ?TYPE_FLOAT;
        |                                                       T == ?TYPE_DOUBLE -&gt;
    26..|      try binary_to_float(Text)
        |      catch error:badarg -&gt;
     9..|          try binary_to_integer(Text) of
     8..|              Int -&gt; float(Int)
        |          catch error:badarg -&gt;
        |              %% It is something like "4e75" that must be turned into "4.0e75"
     1..|              binary_to_float(binary:replace(Text, &lt;&lt;"e"&gt;&gt;, &lt;&lt;".0e"&gt;&gt;))
        |          end
        |      end.
        |  
        |  %% -- binary protocol --
        |  
        |  %% @doc If NumColumns is non-zero, fetches this number of column definitions
        |  %% and an EOF packet. Used by prepare/3.
        |  fetch_column_definitions_if_any(0, _RecvFun, SeqNum) -&gt;
    55..|      {[], SeqNum};
        |  fetch_column_definitions_if_any(N, RecvFun, SeqNum) -&gt;
    69..|      {ok, Defs, SeqNum1} = fetch_column_definitions(RecvFun, SeqNum, N, []),
    69..|      {ok, ?eof_pattern, SeqNum2} = recv_packet(RecvFun, SeqNum1),
    69..|      {Defs, SeqNum2}.
        |  
        |  %% @doc Decodes a packet representing a row in a binary result set.
        |  %% It consists of a 0 byte, then a null bitmap, then the values.
        |  %% Returns a list of length NumColumns with terms of appropriate types for each
        |  %% MySQL type in ColumnTypes.
        |  -spec decode_binary_row(NumColumns :: integer(),
        |                          ColumnDefs :: [#col{}],
        |                          Data :: binary()) -&gt; [term()].
        |  decode_binary_row(NumColumns, ColumnDefs, &lt;&lt;0, Data/binary&gt;&gt;) -&gt;
    74..|      {NullBitMap, Rest} = null_bitmap_decode(NumColumns, Data, 2),
    74..|      decode_binary_row_acc(ColumnDefs, NullBitMap, Rest, []).
        |  
        |  %% @doc Accumulating helper for decode_binary_row/3.
        |  decode_binary_row_acc([_ | ColDefs], &lt;&lt;1:1, NullBitMap/bitstring&gt;&gt;, Data, Acc) -&gt;
        |      %% NULL
     1..|      decode_binary_row_acc(ColDefs, NullBitMap, Data, [null | Acc]);
        |  decode_binary_row_acc([ColDef | ColDefs], &lt;&lt;0:1, NullBitMap/bitstring&gt;&gt;, Data,
        |                        Acc) -&gt;
        |      %% Not NULL
    81..|      {Term, Rest} = decode_binary(ColDef, Data),
    81..|      decode_binary_row_acc(ColDefs, NullBitMap, Rest, [Term | Acc]);
        |  decode_binary_row_acc([], _, &lt;&lt;&gt;&gt;, Acc) -&gt;
    74..|      lists:reverse(Acc).
        |  
        |  %% @doc Decodes a null bitmap as stored by MySQL and returns it in a strait
        |  %% bitstring counting bits from left to right in a tuple with remaining data.
        |  %%
        |  %% In the MySQL null bitmap the bits are stored counting bytes from the left and
        |  %% bits within each byte from the right. (Sort of little endian.)
        |  -spec null_bitmap_decode(NumColumns :: integer(), BitOffset :: integer(),
        |                           Data :: binary()) -&gt;
        |      {NullBitstring :: bitstring(), Rest :: binary()}.
        |  null_bitmap_decode(NumColumns, Data, BitOffset) -&gt;
        |      %% Binary shift right by 3 is equivallent to integer division by 8.
    75..|      BitMapLength = (NumColumns + BitOffset + 7) bsr 3,
    75..|      &lt;&lt;NullBitstring0:BitMapLength/binary, Rest/binary&gt;&gt; = Data,
    75..|      &lt;&lt;_:BitOffset, NullBitstring:NumColumns/bitstring, _/bitstring&gt;&gt; =
    77..|          &lt;&lt; &lt;&lt;(reverse_byte(B))/binary&gt;&gt; || &lt;&lt;B:1/binary&gt;&gt; &lt;= NullBitstring0 &gt;&gt;,
    75..|      {NullBitstring, Rest}.
        |  
        |  %% @doc The reverse of null_bitmap_decode/3. The number of columns is taken to
        |  %% be the number of bits in NullBitstring. Returns the MySQL null bitmap as a
        |  %% binary (i.e. full bytes). BitOffset is the number of unused bits that should
        |  %% be inserted before the other bits.
        |  -spec null_bitmap_encode(bitstring(), integer()) -&gt; binary().
        |  null_bitmap_encode(NullBitstring, BitOffset) -&gt;
    53..|      PayloadLength = bit_size(NullBitstring) + BitOffset,
        |      %% Round up to a multiple of 8.
    53..|      BitMapLength = (PayloadLength + 7) band bnot 7,
    53..|      PadBitsLength = BitMapLength - PayloadLength,
    53..|      PaddedBitstring = &lt;&lt;0:BitOffset, NullBitstring/bitstring, 0:PadBitsLength&gt;&gt;,
    53..|      &lt;&lt; &lt;&lt;(reverse_byte(B))/binary&gt;&gt; || &lt;&lt;B:1/binary&gt;&gt; &lt;= PaddedBitstring &gt;&gt;.
        |  
        |  %% Reverses the bits in a byte.
        |  reverse_byte(&lt;&lt;A:1, B:1, C:1, D:1, E:1, F:1, G:1, H:1&gt;&gt;) -&gt;
   131..|      &lt;&lt;H:1, G:1, F:1, E:1, D:1, C:1, B:1, A:1&gt;&gt;.
        |  
        |  %% @doc Used for executing prepared statements. The bit offset whould be 0 in
        |  %% this case.
        |  -spec build_null_bitmap([any()]) -&gt; binary().
        |  build_null_bitmap(Values) -&gt;
    52..|      Bits = &lt;&lt; &lt;&lt;(case V of null -&gt; 1; _ -&gt; 0 end):1&gt;&gt; || V &lt;- Values &gt;&gt;,
    52..|      null_bitmap_encode(Bits, 0).
        |  
        |  %% Decodes a value as received in the 'binary protocol' result set.
        |  %%
        |  %% The types are type constants for the binary protocol, such as
        |  %% ProtocolBinary::MYSQL_TYPE_STRING. In the guide "MySQL Internals" these are
        |  %% not listed, but we assume that are the same as for the text protocol.
        |  -spec decode_binary(ColDef :: #col{}, Data :: binary()) -&gt;
        |      {Term :: term(), Rest :: binary()}.
        |  decode_binary(#col{type = T}, Data)
        |    when T == ?TYPE_STRING; T == ?TYPE_VARCHAR; T == ?TYPE_VAR_STRING;
        |         T == ?TYPE_ENUM; T == ?TYPE_SET; T == ?TYPE_LONG_BLOB;
        |         T == ?TYPE_MEDIUM_BLOB; T == ?TYPE_BLOB; T == ?TYPE_TINY_BLOB;
        |         T == ?TYPE_GEOMETRY -&gt;
        |      %% As of MySQL 5.6.21 we receive SET and ENUM values as STRING, i.e. we
        |      %% cannot convert them to atom() or sets:set(), etc.
     2..|      lenenc_str(Data);
        |  decode_binary(#col{type = ?TYPE_LONGLONG},
        |                &lt;&lt;Value:64/signed-little, Rest/binary&gt;&gt;) -&gt;
<font color=red>     0..|      {Value, Rest};</font>
        |  decode_binary(#col{type = T}, &lt;&lt;Value:32/signed-little, Rest/binary&gt;&gt;)
        |    when T == ?TYPE_LONG; T == ?TYPE_INT24 -&gt;
     9..|      {Value, Rest};
        |  decode_binary(#col{type = T}, &lt;&lt;Value:16/signed-little, Rest/binary&gt;&gt;)
        |    when T == ?TYPE_SHORT; T == ?TYPE_YEAR -&gt;
<font color=red>     0..|      {Value, Rest};</font>
        |  decode_binary(#col{type = ?TYPE_TINY}, &lt;&lt;Value:8/signed, Rest/binary&gt;&gt;) -&gt;
     4..|      {Value, Rest};
        |  decode_binary(#col{type = T, decimals = S, length = L}, Data)
        |    when T == ?TYPE_DECIMAL; T == ?TYPE_NEWDECIMAL -&gt;
        |      %% Length is the max number of symbols incl. dot and minus sign, e.g. the
        |      %% number of digits plus 2.
    17..|      {Binary, Rest} = lenenc_str(Data),
    17..|      {decode_decimal(Binary, L - 2, S), Rest};
        |  decode_binary(#col{type = ?TYPE_DOUBLE},
        |                &lt;&lt;Value:64/float-little, Rest/binary&gt;&gt;) -&gt;
<font color=red>     0..|      {Value, Rest};</font>
        |  decode_binary(#col{type = ?TYPE_FLOAT},
        |                &lt;&lt;Value:32/float-little, Rest/binary&gt;&gt;) -&gt;
        |      %% There is a precision loss when storing and fetching a 32-bit float.
        |      %% In the text protocol, it is obviously rounded. Storing 3.14 in a FLOAT
        |      %% column and fetching it using the text protocol, we get "3.14" which we
        |      %% parse to the Erlang double as close as possible to 3.14. Fetching the
        |      %% same value as a binary 32-bit float, we get 3.140000104904175. To achieve
        |      %% the same rounding after receiving it as a 32-bit float, we try to do the
        |      %% same rounding here as MySQL does when sending it over the text protocol.
        |      %%
        |      %% This comment explains the idea:
        |      %%
        |      %%     Posted by Geoffrey Downs on March 10 2011 10:26am
        |      %%
        |      %%     Following up... I *think* this is correct for the default float
        |      %%     columns in mysql:
        |      %%
        |      %%     var yourNumber = some floating point value
        |      %%     max decimal precision = 10 ^ (-5 + floor(yourNumber log 10))
        |      %%     So:
        |      %%     0 &lt; x &lt; 10 -&gt; max precision is 0.00001
        |      %%     10 &lt;= x &lt; 100 -&gt; max precision is 0.0001
        |      %%     100 &lt;= x &lt; 1000 -&gt; max precision is 0.001
        |      %%     etc.
        |      %%
        |      %% (From http://dev.mysql.com/doc/refman/5.7/en/problems-with-float.html
        |      %% fetched 10 Nov 2014)
        |      %%
        |      %% The above is almost correct, except for the example in the interval
        |      %% 0 &lt; x &lt; 1. There are 6 significant digits also for these numbers.
        |      %%
        |      %% Now, instead of P = 0.00001 we want the inverse 100000.0 but if we
        |      %% compute Factor = 1 / P we get a precision loss, so instead we do this:
    27..|      Factor = math:pow(10, floor(6 - math:log10(abs(Value)))),
    27..|      RoundedValue = round(Value * Factor) / Factor,
    27..|      {RoundedValue, Rest};
        |  decode_binary(#col{type = ?TYPE_BIT, length = Length}, Data) -&gt;
     4..|      {Binary, Rest} = lenenc_str(Data),
        |      %% Convert to &lt;&lt;_:Length/bitstring&gt;&gt;
     4..|      {decode_bitstring(Binary, Length), Rest};
        |  decode_binary(#col{type = ?TYPE_DATE}, &lt;&lt;Length, Data/binary&gt;&gt;) -&gt;
        |      %% Coded in the same way as DATETIME and TIMESTAMP below, but returned in
        |      %% a simple triple.
     1..|      case {Length, Data} of
<font color=red>     0..|          {0, _} -&gt; {{0, 0, 0}, Data};</font>
     1..|          {4, &lt;&lt;Y:16/little, M, D, Rest/binary&gt;&gt;} -&gt; {{Y, M, D}, Rest}
        |      end;
        |  decode_binary(#col{type = T}, &lt;&lt;Length, Data/binary&gt;&gt;)
        |    when T == ?TYPE_DATETIME; T == ?TYPE_TIMESTAMP -&gt;
        |      %% length (1) -- number of bytes following (valid values: 0, 4, 7, 11)
     3..|      case {Length, Data} of
        |          {0, _} -&gt;
<font color=red>     0..|              {{{0, 0, 0}, {0, 0, 0}}, Data};</font>
        |          {4, &lt;&lt;Y:16/little, M, D, Rest/binary&gt;&gt;} -&gt;
<font color=red>     0..|              {{{Y, M, D}, {0, 0, 0}}, Rest};</font>
        |          {7, &lt;&lt;Y:16/little, M, D, H, Mi, S, Rest/binary&gt;&gt;} -&gt;
     1..|              {{{Y, M, D}, {H, Mi, S}}, Rest};
        |          {11, &lt;&lt;Y:16/little, M, D, H, Mi, S, Micro:32/little, Rest/binary&gt;&gt;} -&gt;
     2..|              {{{Y, M, D}, {H, Mi, S + 0.000001 * Micro}}, Rest}
        |      end;
        |  decode_binary(#col{type = ?TYPE_TIME}, &lt;&lt;Length, Data/binary&gt;&gt;) -&gt;
        |      %% length (1) -- number of bytes following (valid values: 0, 8, 12)
        |      %% is_negative (1) -- (1 if minus, 0 for plus)
        |      %% days (4) -- days
        |      %% hours (1) -- hours
        |      %% minutes (1) -- minutes
        |      %% seconds (1) -- seconds
        |      %% micro_seconds (4) -- micro-seconds
    19..|      case {Length, Data} of
        |          {0, _} -&gt;
<font color=red>     0..|              {{0, {0, 0, 0}}, Data};</font>
        |          {8, &lt;&lt;0, D:32/little, H, M, S, Rest/binary&gt;&gt;} -&gt;
     5..|              {{D, {H, M, S}}, Rest};
        |          {12, &lt;&lt;0, D:32/little, H, M, S, Micro:32/little, Rest/binary&gt;&gt;} -&gt;
     2..|              {{D, {H, M, S + 0.000001 * Micro}}, Rest};
        |          {8, &lt;&lt;1, D:32/little, H, M, S, Rest/binary&gt;&gt;} -&gt;
        |              %% Negative time. Example: '-00:00:01' --&gt; {-1,{23,59,59}}
    10..|              Seconds = ((D * 24 + H) * 60 + M) * 60 + S,
        |              %Seconds = D * 86400 + calendar:time_to_seconds({H, M, S}),
    10..|              {calendar:seconds_to_daystime(-Seconds), Rest};
        |          {12, &lt;&lt;1, D:32/little, H, M, S, Micro:32/little, Rest/binary&gt;&gt;}
        |            when Micro &gt; 0 -&gt;
        |              %% Negate and convert to seconds, excl fractions
     2..|              Seconds = -(((D * 24 + H) * 60 + M) * 60 + S),
        |              %Seconds = -D * 86400 - calendar:time_to_seconds({H, M, S}),
        |              %% Subtract 1 second for the fractions
     2..|              {Days, {Hours, Minutes, Sec}} =
        |                  calendar:seconds_to_daystime(Seconds - 1),
        |              %% Adding the fractions to Sec again makes it a float
     2..|              {{Days, {Hours, Minutes, Sec + 1 - 0.000001 * Micro}}, Rest}
        |      end.
        |  
        |  %% @doc Like trunc/1 but towards negative infinity instead of towards zero.
        |  floor(Value) -&gt;
    27..|      Trunc = trunc(Value),
    27..|      if
    21..|          Trunc =&lt; Value -&gt; Trunc;
     6..|          Trunc &gt; Value -&gt; Trunc - 1 %% for negative values
        |      end.
        |  
        |  %% @doc Encodes a term reprenting av value as a binary for use in the binary
        |  %% protocol. As this is used to encode parameters for prepared statements, the
        |  %% encoding is in its required form, namely `&lt;&lt;Type:8, Sign:8, Value/binary&gt;&gt;'.
        |  -spec encode_param(term()) -&gt; {TypeAndSign :: binary(), Data :: binary()}.
        |  encode_param(null) -&gt;
     1..|      {&lt;&lt;?TYPE_NULL, 0&gt;&gt;, &lt;&lt;&gt;&gt;};
        |  encode_param(Value) when is_binary(Value) -&gt;
     6..|      EncLength = lenenc_int_encode(byte_size(Value)),
     6..|      {&lt;&lt;?TYPE_VAR_STRING, 0&gt;&gt;, &lt;&lt;EncLength/binary, Value/binary&gt;&gt;};
        |  encode_param(Value) when is_integer(Value), Value &gt;= 0 -&gt;
        |      %% We send positive integers with the 'unsigned' flag set.
     8..|      if
        |          Value =&lt; 16#ff -&gt;
     6..|              {&lt;&lt;?TYPE_TINY, 16#80&gt;&gt;, &lt;&lt;Value:8&gt;&gt;};
        |          Value =&lt; 16#ffff -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_SHORT, 16#80&gt;&gt;, &lt;&lt;Value:16/little&gt;&gt;};</font>
        |          Value =&lt; 16#ffffffff -&gt;
     1..|              {&lt;&lt;?TYPE_LONG, 16#80&gt;&gt;, &lt;&lt;Value:32/little&gt;&gt;};
        |          Value =&lt; 16#ffffffffffffffff -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_LONGLONG, 16#80&gt;&gt;, &lt;&lt;Value:64/little&gt;&gt;};</font>
        |          true -&gt;
        |              %% If larger than a 64-bit int we send it as a string. MySQL does
        |              %% silently cast strings in aithmetic expressions. Also, DECIMALs
        |              %% are always sent as strings.
     1..|              encode_param(integer_to_binary(Value))
        |      end;
        |  encode_param(Value) when is_integer(Value), Value &lt; 0 -&gt;
     4..|      if
        |          Value &gt;= -16#80 -&gt;
     2..|              {&lt;&lt;?TYPE_TINY, 0&gt;&gt;, &lt;&lt;Value:8&gt;&gt;};
        |          Value &gt;= -16#8000 -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_SHORT, 0&gt;&gt;, &lt;&lt;Value:16/little&gt;&gt;};</font>
        |          Value &gt;= -16#80000000 -&gt;
     1..|              {&lt;&lt;?TYPE_LONG, 0&gt;&gt;, &lt;&lt;Value:32/little&gt;&gt;};
        |          Value &gt;= -16#8000000000000000 -&gt;
<font color=red>     0..|              {&lt;&lt;?TYPE_LONGLONG, 0&gt;&gt;, &lt;&lt;Value:64/little&gt;&gt;};</font>
        |          true -&gt;
     1..|              encode_param(integer_to_binary(Value))
        |      end;
        |  encode_param(Value) when is_float(Value) -&gt;
    26..|      {&lt;&lt;?TYPE_DOUBLE, 0&gt;&gt;, &lt;&lt;Value:64/float-little&gt;&gt;};
        |  encode_param(Value) when is_bitstring(Value) -&gt;
     2..|      Binary = encode_bitstring(Value),
     2..|      EncLength = lenenc_int_encode(byte_size(Binary)),
     2..|      {&lt;&lt;?TYPE_VAR_STRING, 0&gt;&gt;, &lt;&lt;EncLength/binary, Binary/binary&gt;&gt;};
        |  encode_param(Set) when is_tuple(Set), element(1, Set) == set -&gt;
        |      %% For convenience; encode only. When decoding, a set is returned as binary.
     1..|      Binary = set_to_binary(Set),
     1..|      EncLength = lenenc_int_encode(byte_size(Binary)),
     1..|      {&lt;&lt;?TYPE_SET, 0&gt;&gt;, &lt;&lt;EncLength/binary, Binary/binary&gt;&gt;};
        |  encode_param({Y, M, D}) -&gt;
        |      %% calendar:date()
     1..|      {&lt;&lt;?TYPE_DATE, 0&gt;&gt;, &lt;&lt;4, Y:16/little, M, D&gt;&gt;};
        |  encode_param({{Y, M, D}, {0, 0, 0}}) -&gt;
        |      %% Datetime at midnight
<font color=red>     0..|      {&lt;&lt;?TYPE_DATETIME, 0&gt;&gt;, &lt;&lt;4, Y:16/little, M, D&gt;&gt;};</font>
        |  encode_param({{Y, M, D}, {H, Mi, S}}) when is_integer(S) -&gt;
        |      %% calendar:datetime()
     1..|      {&lt;&lt;?TYPE_DATETIME, 0&gt;&gt;, &lt;&lt;7, Y:16/little, M, D, H, Mi, S&gt;&gt;};
        |  encode_param({{Y, M, D}, {H, Mi, S}}) when is_float(S) -&gt;
        |      %% calendar:datetime() with a float for seconds. This way it looks very
        |      %% similar to a datetime. Microseconds in MySQL timestamps are possible but
        |      %% not very common.
     1..|      Sec = trunc(S),
     1..|      Micro = round(1000000 * (S - Sec)),
     1..|      {&lt;&lt;?TYPE_DATETIME, 0&gt;&gt;, &lt;&lt;11, Y:16/little, M, D, H, Mi, Sec,
        |                                Micro:32/little&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_integer(S), D &gt;= 0 -&gt;
        |      %% calendar:seconds_to_daystime()
     3..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;8, 0, D:32/little, H, M, S&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_integer(S), D &lt; 0 -&gt;
        |      %% Convert to seconds, negate and convert back to daystime form.
        |      %% Then set the minus flag.
     5..|      Seconds = ((D * 24 + H) * 60 + M) * 60 + S,
     5..|      {D1, {H1, M1, S1}} = calendar:seconds_to_daystime(-Seconds),
     5..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;8, 1, D1:32/little, H1, M1, S1&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_float(S), D &gt;= 0 -&gt;
     1..|      S1 = trunc(S),
     1..|      Micro = round(1000000 * (S - S1)),
     1..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;12, 0, D:32/little, H, M, S1, Micro:32/little&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_float(S), S &gt; 0.0, D &lt; 0 -&gt;
     1..|      IntS = trunc(S),
     1..|      Micro = round(1000000 * (1 - S + IntS)),
     1..|      Seconds = (D * 24 + H) * 3600 + M * 60 + IntS + 1,
     1..|      {D1, {M1, H1, S1}} = calendar:seconds_to_daystime(-Seconds),
     1..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;12, 1, D1:32/little, H1, M1, S1, Micro:32/little&gt;&gt;};
        |  encode_param({D, {H, M, 0.0}}) -&gt;
<font color=red>     0..|      encode_param({D, {H, M, 0}}).</font>
        |  
        |  %% -- Value representation in both the text and binary protocols --
        |  
        |  %% @doc Convert to `&lt;&lt;_:Length/bitstring&gt;&gt;'
        |  decode_bitstring(Binary, Length) -&gt;
     9..|      PaddingLength = bit_size(Binary) - Length,
     9..|      &lt;&lt;_:PaddingLength/bitstring, Bitstring:Length/bitstring&gt;&gt; = Binary,
     9..|      Bitstring.
        |  
        |  encode_bitstring(Bitstring) -&gt;
     2..|      Size = bit_size(Bitstring),
     2..|      PaddingSize = byte_size(Bitstring) * 8 - Size,
     2..|      &lt;&lt;0:PaddingSize, Bitstring:Size/bitstring&gt;&gt;.
        |  
        |  decode_decimal(Bin, _P, 0) -&gt;
     8..|      binary_to_integer(Bin);
        |  decode_decimal(Bin, P, S) when P =&lt; 15, S &gt; 0 -&gt;
    16..|      binary_to_float(Bin);
        |  decode_decimal(Bin, P, S) when P &gt;= 16, S &gt; 0 -&gt;
    12..|      Bin.
        |  
        |  %% @doc Converts a set of atoms (or binaries) to a comma-separated binary.
        |  set_to_binary(Set) -&gt;
     1..|      List = [if is_atom(X) -&gt; atom_to_binary(X, utf8); is_binary(X) -&gt; X end
     1..|              || X &lt;- sets:to_list(Set)],
     1..|      case List of
        |          [] -&gt;
<font color=red>     0..|              &lt;&lt;&gt;&gt;;</font>
        |          [First | Rest] -&gt;
     1..|              lists:foldl(fun (X, Acc) -&gt; &lt;&lt;Acc/binary, ",", X/binary&gt;&gt; end,
        |                          First, Rest)
        |      end.
        |  
        |  %% -- Protocol basics: packets --
        |  
        |  %% @doc Wraps Data in packet headers, sends it by calling SendFun and returns
        |  %% {ok, SeqNum1} where SeqNum1 is the next sequence number.
        |  -spec send_packet(sendfun(), Data :: binary(), SeqNum :: integer()) -&gt;
        |      {ok, NextSeqNum :: integer()}.
        |  send_packet(SendFun, Data, SeqNum) -&gt;
   486..|      {WithHeaders, SeqNum1} = add_packet_headers(Data, SeqNum),
   486..|      ok = SendFun(WithHeaders),
   486..|      {ok, SeqNum1}.
        |  
        |  %% @doc Receives data by calling RecvFun and removes the packet headers. Returns
        |  %% the packet contents and the next packet sequence number.
        |  -spec recv_packet(RecvFun :: recvfun(), SeqNum :: integer()) -&gt;
        |      {ok, Data :: binary(), NextSeqNum :: integer()}.
        |  recv_packet(RecvFun, SeqNum) -&gt;
  1245..|      recv_packet(RecvFun, SeqNum, &lt;&lt;&gt;&gt;).
        |  
        |  %% @doc Receives data by calling RecvFun and removes packet headers. Returns the
        |  %% data and the next packet sequence number.
        |  -spec recv_packet(RecvFun :: recvfun(), ExpectSeqNum :: integer(),
        |                    Acc :: binary()) -&gt;
        |      {ok, Data :: binary(), NextSeqNum :: integer()}.
        |  recv_packet(RecvFun, ExpectSeqNum, Acc) -&gt;
  1245..|      case RecvFun(4) of
        |          {ok, Header} -&gt;
  1241..|              {Size, ExpectSeqNum, More} = parse_packet_header(Header),
  1241..|              {ok, Body} = RecvFun(Size),
  1241..|              Acc1 = &lt;&lt;Acc/binary, Body/binary&gt;&gt;,
  1241..|              NextSeqNum = (ExpectSeqNum + 1) band 16#ff,
  1241..|              case More of
  1241..|                  false -&gt; {ok, Acc1, NextSeqNum};
<font color=red>     0..|                  true  -&gt; recv_packet(RecvFun, NextSeqNum, Acc1)</font>
        |              end;
        |          {error, closed} -&gt;
     4..|              {error, closed}
        |      end.
        |  
        |  %% @doc Parses a packet header (32 bits) and returns a tuple.
        |  %%
        |  %% The client should first read a header and parse it. Then read PacketLength
        |  %% bytes. If there are more packets, read another header and read a new packet
        |  %% length of payload until there are no more packets. The seq num should
        |  %% increment from 0 and may wrap around at 255 back to 0.
        |  %%
        |  %% When all packets are read and the payload of all packets are concatenated, it
        |  %% can be parsed using parse_response/1, etc. depending on what type of response
        |  %% is expected.
        |  -spec parse_packet_header(PackerHeader :: binary()) -&gt;
        |      {PacketLength :: integer(),
        |       SeqNum :: integer(),
        |       MorePacketsExist :: boolean()}.
        |  parse_packet_header(&lt;&lt;PacketLength:24/little-integer, SeqNum:8/integer&gt;&gt;) -&gt;
  1242..|      {PacketLength, SeqNum, PacketLength == 16#ffffff}.
        |  
        |  %% @doc Splits a packet body into chunks and wraps them in headers. The
        |  %% resulting list is ready to sent to the socket.
        |  -spec add_packet_headers(PacketBody :: iodata(), SeqNum :: integer()) -&gt;
        |      {PacketWithHeaders :: iodata(), NextSeqNum :: integer()}.
        |  add_packet_headers(PacketBody, SeqNum) -&gt;
   487..|      Bin = iolist_to_binary(PacketBody),
   487..|      Size = size(Bin),
   487..|      SeqNum1 = (SeqNum + 1) rem 16#100,
        |      %% Todo: implement the case when Size &gt;= 16#ffffff.
   487..|      if Size &lt; 16#ffffff -&gt;
   487..|          {[&lt;&lt;Size:24/little, SeqNum:8&gt;&gt;, Bin], SeqNum1}
        |      end.
        |  
        |  -spec parse_ok_packet(binary()) -&gt; #ok{}.
        |  parse_ok_packet(&lt;&lt;?OK:8, Rest/binary&gt;&gt;) -&gt;
   203..|      {AffectedRows, Rest1} = lenenc_int(Rest),
   203..|      {InsertId, Rest2} = lenenc_int(Rest1),
   203..|      &lt;&lt;StatusFlags:16/little, WarningCount:16/little, Msg/binary&gt;&gt; = Rest2,
        |      %% We have CLIENT_PROTOCOL_41 but not CLIENT_SESSION_TRACK enabled. The
        |      %% protocol is conditional. This is from the protocol documentation:
        |      %%
        |      %% if capabilities &amp; CLIENT_PROTOCOL_41 {
        |      %%   int&lt;2&gt; status_flags
        |      %%   int&lt;2&gt; warning_count
        |      %% } elseif capabilities &amp; CLIENT_TRANSACTIONS {
        |      %%   int&lt;2&gt; status_flags
        |      %% }
        |      %% if capabilities &amp; CLIENT_SESSION_TRACK {
        |      %%   string&lt;lenenc&gt; info
        |      %%   if status_flags &amp; SERVER_SESSION_STATE_CHANGED {
        |      %%     string&lt;lenenc&gt; session_state_changes
        |      %%   }
        |      %% } else {
        |      %%   string&lt;EOF&gt; info
        |      %% }
   203..|      #ok{affected_rows = AffectedRows,
        |          insert_id = InsertId,
        |          status = StatusFlags,
        |          warning_count = WarningCount,
        |          msg = Msg}.
        |  
        |  -spec parse_error_packet(binary()) -&gt; #error{}.
        |  parse_error_packet(&lt;&lt;?ERROR:8, ErrNo:16/little, "#", SQLState:5/binary-unit:8,
        |                       Msg/binary&gt;&gt;) -&gt;
        |      %% Error, 4.1 protocol.
        |      %% (Older protocol: &lt;&lt;?ERROR:8, ErrNo:16/little, Msg/binary&gt;&gt;)
     5..|      #error{code = ErrNo, state = SQLState, msg = Msg}.
        |  
        |  -spec parse_eof_packet(binary()) -&gt; #eof{}.
        |  parse_eof_packet(&lt;&lt;?EOF:8, NumWarnings:16/little, StatusFlags:16/little&gt;&gt;) -&gt;
        |      %% EOF packet, 4.1 protocol.
        |      %% (Older protocol: &lt;&lt;?EOF:8&gt;&gt;)
   160..|      #eof{status = StatusFlags, warning_count = NumWarnings}.
        |  
        |  -spec hash_password(Password :: iodata(), Salt :: binary()) -&gt; Hash :: binary().
        |  hash_password(Password, Salt) -&gt;
        |      %% From the "MySQL Internals" manual:
        |      %% SHA1( password ) XOR SHA1( "20-bytes random data from server" &lt;concat&gt;
        |      %%                            SHA1( SHA1( password ) ) )
        |      %% ----
        |      %% Make sure the salt is exactly 20 bytes.
        |      %%
        |      %% The auth data is obviously nul-terminated. For the "native" auth
        |      %% method, it should be a 20 byte salt, so let's trim it in this case.
     5..|      Salt1 = case Salt of
     4..|          &lt;&lt;SaltNoNul:20/binary-unit:8, 0&gt;&gt; -&gt; SaltNoNul;
     1..|          _ when size(Salt) == 20           -&gt; Salt
        |      end,
        |      %% Hash as described above.
     5..|      &lt;&lt;Hash1Num:160&gt;&gt; = Hash1 = crypto:hash(sha, Password),
     5..|      Hash2 = crypto:hash(sha, Hash1),
     5..|      &lt;&lt;Hash3Num:160&gt;&gt; = crypto:hash(sha, &lt;&lt;Salt1/binary, Hash2/binary&gt;&gt;),
     5..|      &lt;&lt;(Hash1Num bxor Hash3Num):160&gt;&gt;.
        |  
        |  %% --- Lowlevel: variable length integers and strings ---
        |  
        |  %% lenenc_int/1 decodes length-encoded-integer values
        |  -spec lenenc_int(Input :: binary()) -&gt; {Value :: integer(), Rest :: binary()}.
  1904..|  lenenc_int(&lt;&lt;Value:8, Rest/bits&gt;&gt;) when Value &lt; 251 -&gt; {Value, Rest};
     1..|  lenenc_int(&lt;&lt;16#fc:8, Value:16/little, Rest/binary&gt;&gt;) -&gt; {Value, Rest};
     1..|  lenenc_int(&lt;&lt;16#fd:8, Value:24/little, Rest/binary&gt;&gt;) -&gt; {Value, Rest};
     1..|  lenenc_int(&lt;&lt;16#fe:8, Value:64/little, Rest/binary&gt;&gt;) -&gt; {Value, Rest}.
        |  
        |  %% Length-encoded-integer encode. Appends the encoded value to Acc.
        |  %% Values not representable in 64 bits are not accepted.
        |  -spec lenenc_int_encode(0..16#ffffffffffffffff) -&gt; binary().
        |  lenenc_int_encode(Value) when Value &lt; 0 -&gt;
<font color=red>     0..|      error(badarg);</font>
        |  lenenc_int_encode(Value) when Value &lt; 251 -&gt;
    10..|      &lt;&lt;Value&gt;&gt;;
        |  lenenc_int_encode(Value) when Value =&lt; 16#ffff -&gt;
     1..|      &lt;&lt;16#fc, Value:16/little&gt;&gt;;
        |  lenenc_int_encode(Value) when Value =&lt; 16#ffffff -&gt;
     1..|      &lt;&lt;16#fd, Value:24/little&gt;&gt;;
        |  lenenc_int_encode(Value) when Value =&lt; 16#ffffffffffffffff -&gt;
     1..|      &lt;&lt;16#fe, Value:64/little&gt;&gt;.
        |  
        |  %% lenenc_str/1 decodes length-encoded-string values
        |  -spec lenenc_str(Input :: binary()) -&gt; {String :: binary(), Rest :: binary()}.
        |  lenenc_str(Bin) -&gt;
  1163..|      {Length, Rest} = lenenc_int(Bin),
  1163..|      &lt;&lt;String:Length/binary, Rest1/binary&gt;&gt; = Rest,
  1163..|      {String, Rest1}.
        |  
        |  %% nts/1 decodes a nul-terminated string
        |  -spec nulterm_str(Input :: binary()) -&gt; {String :: binary(), Rest :: binary()}.
        |  nulterm_str(Bin) -&gt;
     5..|      [String, Rest] = binary:split(Bin, &lt;&lt;0&gt;&gt;),
     5..|      {String, Rest}.
        |  
        |  -ifdef(TEST).
        |  -include_lib("eunit/include/eunit.hrl").
        |  -include("server_status.hrl").
        |  
        |  %% Testing some of the internal functions, mostly the cases we don't cover in
        |  %% other tests.
        |  
        |  decode_text_test() -&gt;
        |      %% Int types
     1..|      lists:foreach(fun (T) -&gt;
     6..|                        ?assertEqual(1, decode_text(#col{type = T}, &lt;&lt;"1"&gt;&gt;))
        |                    end,
        |                    [?TYPE_TINY, ?TYPE_SHORT, ?TYPE_LONG, ?TYPE_LONGLONG,
        |                     ?TYPE_INT24, ?TYPE_YEAR]),
        |  
        |      %% BIT
     1..|      &lt;&lt;217&gt;&gt; = decode_text(#col{type = ?TYPE_BIT, length = 8}, &lt;&lt;217&gt;&gt;),
        |  
        |      %% Floating point and decimal numbers
     1..|      lists:foreach(fun (T) -&gt;
     2..|                        ?assertEqual(3.0, decode_text(#col{type = T}, &lt;&lt;"3.0"&gt;&gt;))
        |                    end,
        |                    [?TYPE_FLOAT, ?TYPE_DOUBLE]),
        |      %% Decimal types
     1..|      lists:foreach(fun (T) -&gt;
     2..|                        ColDef = #col{type = T, decimals = 1, length = 4},
     2..|                        ?assertMatch(3.0, decode_text(ColDef, &lt;&lt;"3.0"&gt;&gt;))
        |                    end,
        |                    [?TYPE_DECIMAL, ?TYPE_NEWDECIMAL]),
     1..|      ?assertEqual(3.0,  decode_text(#col{type = ?TYPE_FLOAT}, &lt;&lt;"3"&gt;&gt;)),
     1..|      ?assertEqual(30.0, decode_text(#col{type = ?TYPE_FLOAT}, &lt;&lt;"3e1"&gt;&gt;)),
     1..|      ?assertEqual(3,    decode_text(#col{type = ?TYPE_LONG}, &lt;&lt;"3"&gt;&gt;)),
        |  
        |      %% Date and time
     1..|      ?assertEqual({2014, 11, 01},
     1..|                   decode_text(#col{type = ?TYPE_DATE}, &lt;&lt;"2014-11-01"&gt;&gt;)),
     1..|      ?assertEqual({0, {23, 59, 01}},
     1..|                   decode_text(#col{type = ?TYPE_TIME}, &lt;&lt;"23:59:01"&gt;&gt;)),
     1..|      ?assertEqual({{2014, 11, 01}, {23, 59, 01}},
        |                   decode_text(#col{type = ?TYPE_DATETIME},
     1..|                               &lt;&lt;"2014-11-01 23:59:01"&gt;&gt;)),
     1..|      ?assertEqual({{2014, 11, 01}, {23, 59, 01}},
        |                   decode_text(#col{type = ?TYPE_TIMESTAMP},
     1..|                               &lt;&lt;"2014-11-01 23:59:01"&gt;&gt;)),
        |  
        |      %% Strings and blobs
     1..|      lists:foreach(fun (T) -&gt;
     9..|                        ColDef = #col{type = T},
     9..|                        ?assertEqual(&lt;&lt;"x"&gt;&gt;, decode_text(ColDef, &lt;&lt;"x"&gt;&gt;))
        |                    end,
        |                    [?TYPE_VARCHAR, ?TYPE_ENUM, ?TYPE_TINY_BLOB,
        |                     ?TYPE_MEDIUM_BLOB, ?TYPE_LONG_BLOB, ?TYPE_BLOB,
        |                     ?TYPE_VAR_STRING, ?TYPE_STRING, ?TYPE_GEOMETRY]),
        |  
        |      %% NULL
     1..|      ?assertEqual(null, decode_text(#col{type = ?TYPE_FLOAT}, null)),
     1..|      ok.
        |  
        |  decode_binary_test() -&gt;
        |      %% Test the special rounding we apply to (single precision) floats.
     1..|      ?assertEqual({1.0, &lt;&lt;&gt;&gt;},
        |                   decode_binary(#col{type = ?TYPE_FLOAT},
     1..|                                 &lt;&lt;1.0:32/float-little&gt;&gt;)),
     1..|      ?assertEqual({0.2, &lt;&lt;&gt;&gt;},
        |                   decode_binary(#col{type = ?TYPE_FLOAT},
     1..|                                 &lt;&lt;0.2:32/float-little&gt;&gt;)),
     1..|      ?assertEqual({-33.3333, &lt;&lt;&gt;&gt;},
        |                   decode_binary(#col{type = ?TYPE_FLOAT},
     1..|                                 &lt;&lt;-33.333333:32/float-little&gt;&gt;)),
     1..|      ?assertEqual({0.000123457, &lt;&lt;&gt;&gt;},
        |                   decode_binary(#col{type = ?TYPE_FLOAT},
     1..|                                 &lt;&lt;0.00012345678:32/float-little&gt;&gt;)),
     1..|      ?assertEqual({1234.57, &lt;&lt;&gt;&gt;},
        |                   decode_binary(#col{type = ?TYPE_FLOAT},
     1..|                                 &lt;&lt;1234.56789:32/float-little&gt;&gt;)),
     1..|      ok.
        |  
        |  encode_param_test() -&gt;
        |      %% Additional representations for common types for convenience
     1..|      {&lt;&lt;?TYPE_SET, 0&gt;&gt;, EncodedSet} = encode_param(sets:from_list([foo, bar])),
     1..|      ?assert(EncodedSet == &lt;&lt;7, "foo,bar"&gt;&gt; orelse
     1..|              EncodedSet == &lt;&lt;7, "bar,foo"&gt;&gt;).
        |  
        |  null_bitmap_test() -&gt;
     1..|      ?assertEqual({&lt;&lt;0, 1:1&gt;&gt;, &lt;&lt;&gt;&gt;}, null_bitmap_decode(9, &lt;&lt;0, 4&gt;&gt;, 2)),
     1..|      ?assertEqual(&lt;&lt;0, 4&gt;&gt;, null_bitmap_encode(&lt;&lt;0, 1:1&gt;&gt;, 2)),
     1..|      ok.
        |  
        |  lenenc_int_test() -&gt;
        |      %% decode
     1..|      ?assertEqual({40, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;40&gt;&gt;)),
     1..|      ?assertEqual({16#ff, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;16#fc, 255, 0&gt;&gt;)),
     1..|      ?assertEqual({16#33aaff, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;16#fd, 16#ff, 16#aa, 16#33&gt;&gt;)),
     1..|      ?assertEqual({16#12345678, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;16#fe, 16#78, 16#56, 16#34,
     1..|                                                   16#12, 0, 0, 0, 0&gt;&gt;)),
        |      %% encode
     1..|      ?assertEqual(&lt;&lt;40&gt;&gt;, lenenc_int_encode(40)),
     1..|      ?assertEqual(&lt;&lt;16#fc, 255, 0&gt;&gt;, lenenc_int_encode(255)),
     1..|      ?assertEqual(&lt;&lt;16#fd, 16#ff, 16#aa, 16#33&gt;&gt;,
     1..|                   lenenc_int_encode(16#33aaff)),
     1..|      ?assertEqual(&lt;&lt;16#fe, 16#78, 16#56, 16#34, 16#12, 0, 0, 0, 0&gt;&gt;,
     1..|                   lenenc_int_encode(16#12345678)),
     1..|      ok.
        |  
        |  lenenc_str_test() -&gt;
     1..|      ?assertEqual({&lt;&lt;"Foo"&gt;&gt;, &lt;&lt;"bar"&gt;&gt;}, lenenc_str(&lt;&lt;3, "Foobar"&gt;&gt;)).
        |  
        |  nulterm_test() -&gt;
     1..|      ?assertEqual({&lt;&lt;"Foo"&gt;&gt;, &lt;&lt;"bar"&gt;&gt;}, nulterm_str(&lt;&lt;"Foo", 0, "bar"&gt;&gt;)).
        |  
        |  parse_header_test() -&gt;
        |      %% Example from "MySQL Internals", revision 307, section 14.1.3.3 EOF_Packet
     1..|      Packet = &lt;&lt;16#05, 16#00, 16#00, 16#05, 16#fe, 16#00, 16#00, 16#02, 16#00&gt;&gt;,
     1..|      &lt;&lt;Header:4/binary-unit:8, Body/binary&gt;&gt; = Packet,
        |      %% Check header contents and body length
     1..|      ?assertEqual({size(Body), 5, false}, parse_packet_header(Header)),
     1..|      ok.
        |  
        |  add_packet_headers_test() -&gt;
     1..|      {Data, 43} = add_packet_headers(&lt;&lt;"foo"&gt;&gt;, 42),
     1..|      ?assertEqual(&lt;&lt;3, 0, 0, 42, "foo"&gt;&gt;, list_to_binary(Data)).
        |  
        |  parse_ok_test() -&gt;
     1..|      Body = &lt;&lt;0, 5, 1, 2, 0, 0, 0, "Foo"&gt;&gt;,
     1..|      ?assertEqual(#ok{affected_rows = 5,
        |                       insert_id = 1,
        |                       status = ?SERVER_STATUS_AUTOCOMMIT,
        |                       warning_count = 0,
        |                       msg = &lt;&lt;"Foo"&gt;&gt;},
     1..|                   parse_ok_packet(Body)).
        |  
        |  parse_error_test() -&gt;
        |      %% Protocol 4.1
     1..|      Body = &lt;&lt;255, 42, 0, "#", "XYZxx", "Foo"&gt;&gt;,
     1..|      ?assertEqual(#error{code = 42, state = &lt;&lt;"XYZxx"&gt;&gt;, msg = &lt;&lt;"Foo"&gt;&gt;},
     1..|                   parse_error_packet(Body)),
     1..|      ok.
        |  
        |  parse_eof_test() -&gt;
        |      %% Example from "MySQL Internals", revision 307, section 14.1.3.3 EOF_Packet
     1..|      Packet = &lt;&lt;16#05, 16#00, 16#00, 16#05, 16#fe, 16#00, 16#00, 16#02, 16#00&gt;&gt;,
     1..|      &lt;&lt;_Header:4/binary-unit:8, Body/binary&gt;&gt; = Packet,
        |      %% Ignore header. Parse body as an eof_packet.
     1..|      ?assertEqual(#eof{warning_count = 0,
        |                        status = ?SERVER_STATUS_AUTOCOMMIT},
     1..|                   parse_eof_packet(Body)),
     1..|      ok.
        |  
        |  hash_password_test() -&gt;
     1..|      ?assertEqual(&lt;&lt;222,207,222,139,41,181,202,13,191,241,
        |                     234,234,73,127,244,101,205,3,28,251&gt;&gt;,
     1..|                   hash_password(&lt;&lt;"foo"&gt;&gt;, &lt;&lt;"abcdefghijklmnopqrst"&gt;&gt;)).
        |  
        |  -endif.
</pre>
</body>
</html>
